<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>vimure.io API documentation</title>
<meta name="description" content="Read and parse data" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vimure.io</code></h1>
</header>
<section id="section-intro">
<p>Read and parse data</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Read and parse data&#34;&#34;&#34;
from asyncio.log import logger

import numpy as np
import pandas as pd
import sktensor as skt
import networkx as nx
import warnings

from abc import ABCMeta
from scipy import sparse

from .log import setup_logging
from .utils import sparse_max, sptensor_from_list

&#34;&#34;&#34;
CONSTANTS
&#34;&#34;&#34;

DEFAULT_SEED = 10

&#34;&#34;&#34;
SETUP
&#34;&#34;&#34;
module_logger = setup_logging(&#34;vm.io&#34;)


class BaseNetwork(metaclass=ABCMeta):
    &#34;&#34;&#34;
    A base abstract class for generation and management of networks, in an adequate format for this project.
    Suitable for representing any type of network, synthetic or real.
    &#34;&#34;&#34;

    def __init__(
        self, N: int, M: int, L: int, K: int, seed: int = DEFAULT_SEED, **kwargs,
    ):
        &#34;&#34;&#34;
        Parameters
        ------------
        N: int
            Number of nodes.
        M: int
            Number of reporters.
        L: int
            Number of layers.
        K: int
            Maximum edge weight in the adjacency matrix. 
            When `K=2`, the adjacency matrix will contain some `Y_{ij}=0` and `Y_{ij}=1`.
        seed: int
            Pseudo random generator seed to use.

        &#34;&#34;&#34;

        self.N = N
        self.M = M
        self.L = L
        self.K = K

        self.seed = seed
        self.prng = np.random.RandomState(self.seed)

    def get_layer(self, layer: int, return_matrix: bool = True):
        &#34;&#34;&#34;
        Return adjacency matrix or nx.Digraph object relative to the requested layer of the observed graph (X)
        &#34;&#34;&#34;
        if return_matrix:
            ret_obj = self.getX()
        else:
            ret_obj = self.getGraphs()

        return ret_obj[layer]

    def setX(self, X):
        dimX = (self.L, self.N, self.N, self.N)
        error_msg = &#34;X has to be a tensor of %s dimensions!&#34; % str(dimX)
        if not (isinstance(X, np.ndarray) or isinstance(X, skt.dtensor) or isinstance(X, skt.sptensor)):
            raise ValueError(error_msg)
        elif X.shape != dimX:
            raise ValueError(error_msg)

        self.X = X

    def getX(self):
        return getattr(self, &#34;X&#34;)
    
    def __repr__(self):
        return f&#34;{self.__class__.__name__} (N={self.N}, M={self.M}, L={self.L}, K={self.K}, seed={self.seed})&#34;
    
    def __str__(self):
        return f&#34;{self.__class__.__name__} (N={self.N}, M={self.M}, L={self.L}, K={self.K}, seed={self.seed})&#34;

    
def parse_graph_from_networkx(G, **kwargs):
    df = nx.to_pandas_edgelist(G)
    return parse_graph_from_edgelist(df, **kwargs)

def parse_graph_from_csv(
    filename: str,
    is_weighted: bool = False,
    is_undirected: bool = True,
    reporter=&#34;reporter&#34;,
    layer=&#34;layer&#34;,
    ego=&#34;Ego&#34;,
    alter=&#34;Alter&#34;,
    weight=&#34;weight&#34;,
    K=None,
    **kwargs,
):
    &#34;&#34;&#34;
    Parameters
    -----------

    filename: str
        path to CSV file
    &#34;&#34;&#34;

    df = pd.read_csv(filename)
    return parse_graph_from_edgelist(
        df,
        is_weighted=is_weighted,
        is_undirected=is_undirected,
        reporter=reporter,
        layer=layer,
        ego=ego,
        alter=alter,
        weight=weight,
        **kwargs,
    )


def parse_graph_from_edgelist(
    df: pd.DataFrame,
    nodes: list = None,
    reporters: list = None,
    is_weighted: bool = False,
    is_undirected: bool = False,
    reporter=&#34;reporter&#34;,
    layer=&#34;layer&#34;,
    ego=&#34;Ego&#34;,
    alter=&#34;Alter&#34;,
    weight=&#34;weight&#34;,
    K=None,
    R=None,
    **kwargs,
):
    &#34;&#34;&#34;
    Parameters
    -----------

    df: pd.DataFrame
        DataFrame representing the edgelist
    nodes: list
        list of all nodes
    reporters: list
        list of the nodes who took the survey
    is_weighted: bool
        True if we should add weights to adjacency matrices
    reporter: str
        reporter column
    layer: str
        layer column
    ego: str
        ego column
    alter: str
        alter column
    weight: str
        weight column
    K: int
        maximum value on the adjacency matrix
    R: list of list of sparse COO array NxN, tot dimension is MxLxNxN (same dimension of the data)
        If this is None, we assume reporters only reports their own ties (of any type)
    **kwargs:
        any other parameters to be sent to RealNetwork.__init__
    &#34;&#34;&#34;

    if not isinstance(df, pd.DataFrame):
        msg = &#34;Invalid &#39;type&#39; ({}) of argument &#39;df&#39;&#34;.format(type(df))
        raise ValueError(msg)

    expected_columns = [ego, alter, reporter, layer, weight]
    real_columns = df.columns.values
    diff_columns = list(set(expected_columns) - set(real_columns))

    # Dataframe has no expected column
    if len(diff_columns) == len(expected_columns):
        msg = &#34;Invalid columns in &#39;df&#39;. Hint: Use params&#34;
        msg += &#34; ego,alter,... for mapping column names.&#34;
        raise ValueError(msg)
        
    if ego in diff_columns or alter in diff_columns:
        msg = &#34;Columns &#39;{}&#39; or &#39;{}&#39; were not found in &#39;df&#39;. Hint: Use params&#34;.format(ego, alter)
        msg += &#34; ego,alter,... for mapping column names.&#34;
        raise ValueError(msg)
        
    if reporter in diff_columns:
        msg = &#34;&#39;{}&#39; column not found in &#39;df&#39;. Using &#39;{}&#39; columns as reporter.&#34;.format(reporter, ego)
        warnings.warn(msg, UserWarning)
        df.loc[:, reporter] = df[ego]
        
    if layer in diff_columns:
        df.loc[:, layer] = &#34;1&#34;
        
    if weight in diff_columns:
        df.loc[:, weight] = 1

    # Put nodes and reporters in alphabetical order
    layers = sorted(df[layer].unique())
    
    if nodes is None:
        msg = &#34;The set of nodes was not informed, &#34;
        msg += &#34;using {} and {} columns to infer nodes.&#34;.format(ego, alter)
        warnings.warn(msg, UserWarning)
        nodes = set(sum(df[[ego, alter]].values.tolist(), []))

    if np.logical_or(~df[ego].isin(nodes), ~df[alter].isin(nodes)).any():
        msg = &#34;Some nodes in the edgelist are not listed in the `nodes` variable.&#34;
        raise ValueError(msg)

    L = len(layers)
    N = len(nodes)
    if reporters is None:
        msg = &#34;The set of reporters was not informed, &#34;
        msg += &#34;assuming set(reporters) = set(nodes) and N = M.&#34;
        warnings.warn(msg, UserWarning)

        reporters = nodes

    if not set(reporters).issubset(nodes):
        raise ValueError(&#34;Set of reporters is not a subset of nodes!&#34;)
    M = len(reporters)

    # Remove duplicates
    df = df[expected_columns].drop_duplicates()

    &#34;&#34;&#34;
    Configure mappers
    &#34;&#34;&#34;
    # map str to id
    nodeName2Id = {}
    nodeId2Name = {}
    for i, l in enumerate(nodes):
        nodeName2Id[l] = i
        nodeId2Name[i] = l

    layerName2Id = {}
    layerId2Name = {}
    for i, l in enumerate(layers):
        layerName2Id[l] = i
        layerId2Name[i] = l

    if R is None:
        msg = &#34;Reporters Mask was not informed (parameter R). &#34;
        msg += &#34;Parser will build it from reporter column, &#34;
        msg += &#34;assuming a reporter can only report their own ties.&#34;

        warnings.warn(msg, UserWarning)

        &#34;&#34;&#34;
        Infer R
        &#34;&#34;&#34;

        # While in theory R would be of dimension (M x L), we chose it to be (N x L)
        #  since R and X are later converted to sparse tensors
        #  and then we don&#39;t need to create a reporterName2Id mapping.
        #  We can use the same mapping of nodeName2Id
        R = [[[] for _ in range(L)] for _ in range(N)]

        for layerName, layerIdx in layerName2Id.items():
            for repName in reporters:
                rep = nodeName2Id[repName]
                # This reporter can report on any ties involving themselves
                row = rep * np.ones(N - 1)
                col = np.array(list(set(np.arange(N)) - set([rep])))
                data = np.ones(N - 1)

                R[rep][layerIdx] = sparse.coo_matrix((data, (row, col)), shape=(N, N))
                R[rep][layerIdx] = sparse_max(R[rep][layerIdx], R[rep][layerIdx].T,)
                R[rep][layerIdx] = R[rep][layerIdx].tocoo()

        # TODO: If some reporters do not appear in the edgelit, we should also warn the user
    elif R.shape != (L, N, N, M):
        msg = &#34;Dimensions of reporter mask (R) do not match L x N x N x M&#34;
        module_logger.error(msg)
        raise ValueError(msg)

    &#34;&#34;&#34;
    Set X
    &#34;&#34;&#34;
    g = df.groupby(by=[reporter, layer])
    X = [[[] for _ in range(L)] for _ in range(N)]  # M x L list
    for idx, n in g:
        row = n[ego].map(nodeName2Id).values
        col = n[alter].map(nodeName2Id).values

        if is_weighted:
            data = n[weight].values
        else:
            data = (n[weight].values &gt; 0).astype(&#34;int&#34;)

        data_nnz = data &gt; 0  # Keep track of nonzero entries
        rel_data = data[data_nnz]  # Relevant data
        rep = nodeName2Id[idx[0]]  # Current reporter
        layer = layerName2Id[idx[1]]  # Current layer

        X[rep][layer] = sparse.coo_matrix((rel_data, (row[data_nnz], col[data_nnz])), (N, N))
        if is_undirected:
            X[rep][layer] = sparse_max(X[rep][layer], X[rep][layer].T,)
            X[rep][layer] = X[rep][layer].tocoo()

    # Convert to sptensor object
    X = sptensor_from_list(X)

    if isinstance(R, list):
        R = sptensor_from_list(R)

    &#34;&#34;&#34;
    Set K
    &#34;&#34;&#34;
    if K is None:
        K = np.max(X.vals) + 1
        msg = f&#34;Parameter K was None. Defaulting to: {K}&#34;
        warnings.warn(msg, UserWarning)
    else:
        K = np.max(X) + 1

    # TODO: For future users, we might want to keep track of nodeName2Id too (nodeId2Name)
    network = RealNetwork(X=X, R=R, L=L, N=N, M=M, K=K, nodeNames=nodeId2Name, **kwargs)
    return network


class RealNetwork(BaseNetwork):
    def __init__(self, X, R=None, **kwargs):
        &#34;&#34;&#34;
        Parameters
        ------------

        X: tensor of dimensions L x N x N x M
            Represents the observed network as reported by each reporter M
        R: list of list of sparse COO array NxN, tot dimension is L x N x N x M (same dimension of the data)
            If this is None, we assume reporters only reports their own ties (of any type)
        &#34;&#34;&#34;

        super().__init__(**kwargs)

        self.setX(X)
        self.R = R

        if &#34;nodeNames&#34; in kwargs:
            self.nodeNames = pd.DataFrame(kwargs[&#34;nodeNames&#34;].items(), columns = [&#34;id&#34;, &#34;name&#34;])

        def __repr__(self):
            return f&#34;{self.__class__.__name__} (N={self.N}, M={self.M}, L={self.L}, K={self.K}, number_ties={self.X.vals.sum()})&#34;

        def __str__(self):
            return f&#34;{self.__class__.__name__} (N={self.N}, M={self.M}, L={self.L}, K={self.K}, number_ties={self.X.vals.sum()})&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="vimure.io.DEFAULT_SEED"><code class="name">var <span class="ident">DEFAULT_SEED</span></code></dt>
<dd>
<div class="desc"><p>SETUP</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vimure.io.parse_graph_from_csv"><code class="name flex">
<span>def <span class="ident">parse_graph_from_csv</span></span>(<span>filename: str, is_weighted: bool = False, is_undirected: bool = True, reporter='reporter', layer='layer', ego='Ego', alter='Alter', weight='weight', K=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>path to CSV file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_graph_from_csv(
    filename: str,
    is_weighted: bool = False,
    is_undirected: bool = True,
    reporter=&#34;reporter&#34;,
    layer=&#34;layer&#34;,
    ego=&#34;Ego&#34;,
    alter=&#34;Alter&#34;,
    weight=&#34;weight&#34;,
    K=None,
    **kwargs,
):
    &#34;&#34;&#34;
    Parameters
    -----------

    filename: str
        path to CSV file
    &#34;&#34;&#34;

    df = pd.read_csv(filename)
    return parse_graph_from_edgelist(
        df,
        is_weighted=is_weighted,
        is_undirected=is_undirected,
        reporter=reporter,
        layer=layer,
        ego=ego,
        alter=alter,
        weight=weight,
        **kwargs,
    )</code></pre>
</details>
</dd>
<dt id="vimure.io.parse_graph_from_edgelist"><code class="name flex">
<span>def <span class="ident">parse_graph_from_edgelist</span></span>(<span>df: pandas.core.frame.DataFrame, nodes: list = None, reporters: list = None, is_weighted: bool = False, is_undirected: bool = False, reporter='reporter', layer='layer', ego='Ego', alter='Alter', weight='weight', K=None, R=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>DataFrame representing the edgelist</dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>list</code></dt>
<dd>list of all nodes</dd>
<dt><strong><code>reporters</code></strong> :&ensp;<code>list</code></dt>
<dd>list of the nodes who took the survey</dd>
<dt><strong><code>is_weighted</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if we should add weights to adjacency matrices</dd>
<dt><strong><code>reporter</code></strong> :&ensp;<code>str</code></dt>
<dd>reporter column</dd>
<dt><strong><code>layer</code></strong> :&ensp;<code>str</code></dt>
<dd>layer column</dd>
<dt><strong><code>ego</code></strong> :&ensp;<code>str</code></dt>
<dd>ego column</dd>
<dt><strong><code>alter</code></strong> :&ensp;<code>str</code></dt>
<dd>alter column</dd>
<dt><strong><code>weight</code></strong> :&ensp;<code>str</code></dt>
<dd>weight column</dd>
<dt><strong><code>K</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum value on the adjacency matrix</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>sparse COO array NxN, tot dimension is MxLxNxN (same dimension</code> of <code>the data)</code></dt>
<dd>If this is None, we assume reporters only reports their own ties (of any type)</dd>
</dl>
<p>**kwargs:
any other parameters to be sent to RealNetwork.<strong>init</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_graph_from_edgelist(
    df: pd.DataFrame,
    nodes: list = None,
    reporters: list = None,
    is_weighted: bool = False,
    is_undirected: bool = False,
    reporter=&#34;reporter&#34;,
    layer=&#34;layer&#34;,
    ego=&#34;Ego&#34;,
    alter=&#34;Alter&#34;,
    weight=&#34;weight&#34;,
    K=None,
    R=None,
    **kwargs,
):
    &#34;&#34;&#34;
    Parameters
    -----------

    df: pd.DataFrame
        DataFrame representing the edgelist
    nodes: list
        list of all nodes
    reporters: list
        list of the nodes who took the survey
    is_weighted: bool
        True if we should add weights to adjacency matrices
    reporter: str
        reporter column
    layer: str
        layer column
    ego: str
        ego column
    alter: str
        alter column
    weight: str
        weight column
    K: int
        maximum value on the adjacency matrix
    R: list of list of sparse COO array NxN, tot dimension is MxLxNxN (same dimension of the data)
        If this is None, we assume reporters only reports their own ties (of any type)
    **kwargs:
        any other parameters to be sent to RealNetwork.__init__
    &#34;&#34;&#34;

    if not isinstance(df, pd.DataFrame):
        msg = &#34;Invalid &#39;type&#39; ({}) of argument &#39;df&#39;&#34;.format(type(df))
        raise ValueError(msg)

    expected_columns = [ego, alter, reporter, layer, weight]
    real_columns = df.columns.values
    diff_columns = list(set(expected_columns) - set(real_columns))

    # Dataframe has no expected column
    if len(diff_columns) == len(expected_columns):
        msg = &#34;Invalid columns in &#39;df&#39;. Hint: Use params&#34;
        msg += &#34; ego,alter,... for mapping column names.&#34;
        raise ValueError(msg)
        
    if ego in diff_columns or alter in diff_columns:
        msg = &#34;Columns &#39;{}&#39; or &#39;{}&#39; were not found in &#39;df&#39;. Hint: Use params&#34;.format(ego, alter)
        msg += &#34; ego,alter,... for mapping column names.&#34;
        raise ValueError(msg)
        
    if reporter in diff_columns:
        msg = &#34;&#39;{}&#39; column not found in &#39;df&#39;. Using &#39;{}&#39; columns as reporter.&#34;.format(reporter, ego)
        warnings.warn(msg, UserWarning)
        df.loc[:, reporter] = df[ego]
        
    if layer in diff_columns:
        df.loc[:, layer] = &#34;1&#34;
        
    if weight in diff_columns:
        df.loc[:, weight] = 1

    # Put nodes and reporters in alphabetical order
    layers = sorted(df[layer].unique())
    
    if nodes is None:
        msg = &#34;The set of nodes was not informed, &#34;
        msg += &#34;using {} and {} columns to infer nodes.&#34;.format(ego, alter)
        warnings.warn(msg, UserWarning)
        nodes = set(sum(df[[ego, alter]].values.tolist(), []))

    if np.logical_or(~df[ego].isin(nodes), ~df[alter].isin(nodes)).any():
        msg = &#34;Some nodes in the edgelist are not listed in the `nodes` variable.&#34;
        raise ValueError(msg)

    L = len(layers)
    N = len(nodes)
    if reporters is None:
        msg = &#34;The set of reporters was not informed, &#34;
        msg += &#34;assuming set(reporters) = set(nodes) and N = M.&#34;
        warnings.warn(msg, UserWarning)

        reporters = nodes

    if not set(reporters).issubset(nodes):
        raise ValueError(&#34;Set of reporters is not a subset of nodes!&#34;)
    M = len(reporters)

    # Remove duplicates
    df = df[expected_columns].drop_duplicates()

    &#34;&#34;&#34;
    Configure mappers
    &#34;&#34;&#34;
    # map str to id
    nodeName2Id = {}
    nodeId2Name = {}
    for i, l in enumerate(nodes):
        nodeName2Id[l] = i
        nodeId2Name[i] = l

    layerName2Id = {}
    layerId2Name = {}
    for i, l in enumerate(layers):
        layerName2Id[l] = i
        layerId2Name[i] = l

    if R is None:
        msg = &#34;Reporters Mask was not informed (parameter R). &#34;
        msg += &#34;Parser will build it from reporter column, &#34;
        msg += &#34;assuming a reporter can only report their own ties.&#34;

        warnings.warn(msg, UserWarning)

        &#34;&#34;&#34;
        Infer R
        &#34;&#34;&#34;

        # While in theory R would be of dimension (M x L), we chose it to be (N x L)
        #  since R and X are later converted to sparse tensors
        #  and then we don&#39;t need to create a reporterName2Id mapping.
        #  We can use the same mapping of nodeName2Id
        R = [[[] for _ in range(L)] for _ in range(N)]

        for layerName, layerIdx in layerName2Id.items():
            for repName in reporters:
                rep = nodeName2Id[repName]
                # This reporter can report on any ties involving themselves
                row = rep * np.ones(N - 1)
                col = np.array(list(set(np.arange(N)) - set([rep])))
                data = np.ones(N - 1)

                R[rep][layerIdx] = sparse.coo_matrix((data, (row, col)), shape=(N, N))
                R[rep][layerIdx] = sparse_max(R[rep][layerIdx], R[rep][layerIdx].T,)
                R[rep][layerIdx] = R[rep][layerIdx].tocoo()

        # TODO: If some reporters do not appear in the edgelit, we should also warn the user
    elif R.shape != (L, N, N, M):
        msg = &#34;Dimensions of reporter mask (R) do not match L x N x N x M&#34;
        module_logger.error(msg)
        raise ValueError(msg)

    &#34;&#34;&#34;
    Set X
    &#34;&#34;&#34;
    g = df.groupby(by=[reporter, layer])
    X = [[[] for _ in range(L)] for _ in range(N)]  # M x L list
    for idx, n in g:
        row = n[ego].map(nodeName2Id).values
        col = n[alter].map(nodeName2Id).values

        if is_weighted:
            data = n[weight].values
        else:
            data = (n[weight].values &gt; 0).astype(&#34;int&#34;)

        data_nnz = data &gt; 0  # Keep track of nonzero entries
        rel_data = data[data_nnz]  # Relevant data
        rep = nodeName2Id[idx[0]]  # Current reporter
        layer = layerName2Id[idx[1]]  # Current layer

        X[rep][layer] = sparse.coo_matrix((rel_data, (row[data_nnz], col[data_nnz])), (N, N))
        if is_undirected:
            X[rep][layer] = sparse_max(X[rep][layer], X[rep][layer].T,)
            X[rep][layer] = X[rep][layer].tocoo()

    # Convert to sptensor object
    X = sptensor_from_list(X)

    if isinstance(R, list):
        R = sptensor_from_list(R)

    &#34;&#34;&#34;
    Set K
    &#34;&#34;&#34;
    if K is None:
        K = np.max(X.vals) + 1
        msg = f&#34;Parameter K was None. Defaulting to: {K}&#34;
        warnings.warn(msg, UserWarning)
    else:
        K = np.max(X) + 1

    # TODO: For future users, we might want to keep track of nodeName2Id too (nodeId2Name)
    network = RealNetwork(X=X, R=R, L=L, N=N, M=M, K=K, nodeNames=nodeId2Name, **kwargs)
    return network</code></pre>
</details>
</dd>
<dt id="vimure.io.parse_graph_from_networkx"><code class="name flex">
<span>def <span class="ident">parse_graph_from_networkx</span></span>(<span>G, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_graph_from_networkx(G, **kwargs):
    df = nx.to_pandas_edgelist(G)
    return parse_graph_from_edgelist(df, **kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vimure.io.BaseNetwork"><code class="flex name class">
<span>class <span class="ident">BaseNetwork</span></span>
<span>(</span><span>N: int, M: int, L: int, K: int, seed: int = 10, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A base abstract class for generation and management of networks, in an adequate format for this project.
Suitable for representing any type of network, synthetic or real.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of nodes.</dd>
<dt><strong><code>M</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of reporters.</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of layers.</dd>
<dt><strong><code>K</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum edge weight in the adjacency matrix.
When <code>K=2</code>, the adjacency matrix will contain some <code>Y_{ij}=0</code> and <code>Y_{ij}=1</code>.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Pseudo random generator seed to use.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseNetwork(metaclass=ABCMeta):
    &#34;&#34;&#34;
    A base abstract class for generation and management of networks, in an adequate format for this project.
    Suitable for representing any type of network, synthetic or real.
    &#34;&#34;&#34;

    def __init__(
        self, N: int, M: int, L: int, K: int, seed: int = DEFAULT_SEED, **kwargs,
    ):
        &#34;&#34;&#34;
        Parameters
        ------------
        N: int
            Number of nodes.
        M: int
            Number of reporters.
        L: int
            Number of layers.
        K: int
            Maximum edge weight in the adjacency matrix. 
            When `K=2`, the adjacency matrix will contain some `Y_{ij}=0` and `Y_{ij}=1`.
        seed: int
            Pseudo random generator seed to use.

        &#34;&#34;&#34;

        self.N = N
        self.M = M
        self.L = L
        self.K = K

        self.seed = seed
        self.prng = np.random.RandomState(self.seed)

    def get_layer(self, layer: int, return_matrix: bool = True):
        &#34;&#34;&#34;
        Return adjacency matrix or nx.Digraph object relative to the requested layer of the observed graph (X)
        &#34;&#34;&#34;
        if return_matrix:
            ret_obj = self.getX()
        else:
            ret_obj = self.getGraphs()

        return ret_obj[layer]

    def setX(self, X):
        dimX = (self.L, self.N, self.N, self.N)
        error_msg = &#34;X has to be a tensor of %s dimensions!&#34; % str(dimX)
        if not (isinstance(X, np.ndarray) or isinstance(X, skt.dtensor) or isinstance(X, skt.sptensor)):
            raise ValueError(error_msg)
        elif X.shape != dimX:
            raise ValueError(error_msg)

        self.X = X

    def getX(self):
        return getattr(self, &#34;X&#34;)
    
    def __repr__(self):
        return f&#34;{self.__class__.__name__} (N={self.N}, M={self.M}, L={self.L}, K={self.K}, seed={self.seed})&#34;
    
    def __str__(self):
        return f&#34;{self.__class__.__name__} (N={self.N}, M={self.M}, L={self.L}, K={self.K}, seed={self.seed})&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vimure.io.RealNetwork" href="#vimure.io.RealNetwork">RealNetwork</a></li>
<li><a title="vimure.synthetic.BaseSyntheticNetwork" href="synthetic.html#vimure.synthetic.BaseSyntheticNetwork">BaseSyntheticNetwork</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="vimure.io.BaseNetwork.getX"><code class="name flex">
<span>def <span class="ident">getX</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getX(self):
    return getattr(self, &#34;X&#34;)</code></pre>
</details>
</dd>
<dt id="vimure.io.BaseNetwork.get_layer"><code class="name flex">
<span>def <span class="ident">get_layer</span></span>(<span>self, layer: int, return_matrix: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return adjacency matrix or nx.Digraph object relative to the requested layer of the observed graph (X)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_layer(self, layer: int, return_matrix: bool = True):
    &#34;&#34;&#34;
    Return adjacency matrix or nx.Digraph object relative to the requested layer of the observed graph (X)
    &#34;&#34;&#34;
    if return_matrix:
        ret_obj = self.getX()
    else:
        ret_obj = self.getGraphs()

    return ret_obj[layer]</code></pre>
</details>
</dd>
<dt id="vimure.io.BaseNetwork.setX"><code class="name flex">
<span>def <span class="ident">setX</span></span>(<span>self, X)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setX(self, X):
    dimX = (self.L, self.N, self.N, self.N)
    error_msg = &#34;X has to be a tensor of %s dimensions!&#34; % str(dimX)
    if not (isinstance(X, np.ndarray) or isinstance(X, skt.dtensor) or isinstance(X, skt.sptensor)):
        raise ValueError(error_msg)
    elif X.shape != dimX:
        raise ValueError(error_msg)

    self.X = X</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vimure.io.RealNetwork"><code class="flex name class">
<span>class <span class="ident">RealNetwork</span></span>
<span>(</span><span>X, R=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A base abstract class for generation and management of networks, in an adequate format for this project.
Suitable for representing any type of network, synthetic or real.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>tensor</code> of <code>dimensions L x N x N x M</code></dt>
<dd>Represents the observed network as reported by each reporter M</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>sparse COO array NxN, tot dimension is L x N x N x M (same dimension</code> of <code>the data)</code></dt>
<dd>If this is None, we assume reporters only reports their own ties (of any type)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RealNetwork(BaseNetwork):
    def __init__(self, X, R=None, **kwargs):
        &#34;&#34;&#34;
        Parameters
        ------------

        X: tensor of dimensions L x N x N x M
            Represents the observed network as reported by each reporter M
        R: list of list of sparse COO array NxN, tot dimension is L x N x N x M (same dimension of the data)
            If this is None, we assume reporters only reports their own ties (of any type)
        &#34;&#34;&#34;

        super().__init__(**kwargs)

        self.setX(X)
        self.R = R

        if &#34;nodeNames&#34; in kwargs:
            self.nodeNames = pd.DataFrame(kwargs[&#34;nodeNames&#34;].items(), columns = [&#34;id&#34;, &#34;name&#34;])

        def __repr__(self):
            return f&#34;{self.__class__.__name__} (N={self.N}, M={self.M}, L={self.L}, K={self.K}, number_ties={self.X.vals.sum()})&#34;

        def __str__(self):
            return f&#34;{self.__class__.__name__} (N={self.N}, M={self.M}, L={self.L}, K={self.K}, number_ties={self.X.vals.sum()})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vimure.io.BaseNetwork" href="#vimure.io.BaseNetwork">BaseNetwork</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vimure.io.BaseNetwork" href="#vimure.io.BaseNetwork">BaseNetwork</a></b></code>:
<ul class="hlist">
<li><code><a title="vimure.io.BaseNetwork.get_layer" href="#vimure.io.BaseNetwork.get_layer">get_layer</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vimure" href="index.html">vimure</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="vimure.io.DEFAULT_SEED" href="#vimure.io.DEFAULT_SEED">DEFAULT_SEED</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vimure.io.parse_graph_from_csv" href="#vimure.io.parse_graph_from_csv">parse_graph_from_csv</a></code></li>
<li><code><a title="vimure.io.parse_graph_from_edgelist" href="#vimure.io.parse_graph_from_edgelist">parse_graph_from_edgelist</a></code></li>
<li><code><a title="vimure.io.parse_graph_from_networkx" href="#vimure.io.parse_graph_from_networkx">parse_graph_from_networkx</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vimure.io.BaseNetwork" href="#vimure.io.BaseNetwork">BaseNetwork</a></code></h4>
<ul class="">
<li><code><a title="vimure.io.BaseNetwork.getX" href="#vimure.io.BaseNetwork.getX">getX</a></code></li>
<li><code><a title="vimure.io.BaseNetwork.get_layer" href="#vimure.io.BaseNetwork.get_layer">get_layer</a></code></li>
<li><code><a title="vimure.io.BaseNetwork.setX" href="#vimure.io.BaseNetwork.setX">setX</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vimure.io.RealNetwork" href="#vimure.io.RealNetwork">RealNetwork</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>