[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "VIMuRe v0.1 (latest)",
    "section": "",
    "text": "Suppose you want to find out the “true” network of social ties between \\(n\\) individuals and you query \\(m\\) “reporters” within this network (where \\(m \\le n\\)) about such ties. These ties could, for instance, represent relationships commonly studied in the social sciences — such as loaning money, giving advice, or sharing food.\nSuppose, also, that you ask them questions in both directions: “Who comes to person \\(i\\) to borrow money?” But also, “Who does person \\(i\\) go to when borrowing money?” As it is doubtful that the responses given by the reporters will match perfectly, you will almost surely end up with varying perspectives on what should be the same relationship and, so too, varying perspectives on the structure of the overall social network. The question then is, how do you make sense of this data in the face of inconsistent reports and potentially unreliable reporters?\nThe model in the VIMuRe package is our proposed solution to this problem. It fits a latent network model from multiply-sampled social network data using Bayesian inference, returning a posterior distribution that can later be used to obtain samples or a point-estimate network (e.g., as an igraph object). The package was written in Python and R and is available on GitHub (https://github.com/latentnetworks/vimure).\n\n\n\nInput: multiply-sampled social network data as an edgelist or an igraph object.\nOutput: a fitted latent network model that can be used to obtain samples or a point-estimate network (an igraph object) from the posterior distribution of the fitted model.\n\n\n\n\n\nHead to the 📦 Installation page to learn how to install the package (either R or Python).\nCheck out the 💻 Tutorials page to learn how to use the package."
  },
  {
    "objectID": "latest/install.html",
    "href": "latest/install.html",
    "title": "📦 Installation",
    "section": "",
    "text": "VIMuRe is available in both R and Python. The R implementation is a wrapper around the Python implementation. Both packages are in active development and are not yet on CRAN or PyPI. Use the installation instructions below to install the latest development version.\nChoose your language:"
  },
  {
    "objectID": "latest/install.html#step-01-install-reticulate",
    "href": "latest/install.html#step-01-install-reticulate",
    "title": "📦 Installation",
    "section": "Step 01: Install reticulate",
    "text": "Step 01: Install reticulate\nOpen your R console and type the following command:\ninstall.packages(\"reticulate\")\n\n\n\n\n\n\nWhy do I need this package?\n\n\n\n\n\n\nOur core code is written in python, so we use reticulate to integrate our model in R. This package allows you to use Python within your R session in a seamless, high-performance interoperable way.\nreticulate will look for the python installed on your computer. If for some reason it cannot find it, you may be prompted to download and install miniconda.\n\nminiconda is the recommended installation method for most users, as it is easier to ensure that the newly installed python is isolated from other python installs you have in your system.\nIf you initially declined the miniconda installation prompt, you can later manually install miniconda by running reticulate::install_miniconda()."
  },
  {
    "objectID": "latest/install.html#step-02-install-the-latest-vimure-v0.1",
    "href": "latest/install.html#step-02-install-the-latest-vimure-v0.1",
    "title": "📦 Installation",
    "section": "Step 02: Install the latest vimure (v0.1)",
    "text": "Step 02: Install the latest vimure (v0.1)\nIn your R console, type the following commands:\nrequire(devtools)\ndevtools::install_github(\"latentnetworks/vimure\", subdir=\"src/R\", ref=\"main\")\nCheck out devtools package documentation if you are not familiar with it."
  },
  {
    "objectID": "latest/install.html#step-03-install-the-python-package",
    "href": "latest/install.html#step-03-install-the-python-package",
    "title": "📦 Installation",
    "section": "Step 03: Install the Python package",
    "text": "Step 03: Install the Python package\nYou must install the python package before using the R package. This is because the R package is a wrapper around the Python package. You can do this without leaving R, though. Just type the following command in your R console:\nrequire(vimure)\nvimure::install_vimure()\nIf you are not using RStudio, i.e., you are using R in the terminal, you may need to restart your R session after installing the Python package.\nNot a fan of having to do this python setup? Please add a message to this discussion to tell us you would like to see an easier installation process for R."
  },
  {
    "objectID": "latest/people.html",
    "href": "latest/people.html",
    "title": "People",
    "section": "",
    "text": "Who we are\nThe people behind the conception, development, and maintenance of VIMuRe are listed below.\n\n\n\n\n\nDr. Caterina De Bacco CyberValley Research Group Leader MPI for Intelligent Systems 🧑‍💻 core package developer\n\n\n\n\n\n\nMartina Contisciani Ph.D. Student MPI for Intelligent Systems 🧑‍💻 core package developer\n\n\n\n\n\n\nDr. Jon Cardoso-Silva Assist. Prof. Lecturer LSE Data Science Institute 🧑‍💻 core package developer\n\n\n\n\n\n\nDr. Hadiseh Safdari Postdoctoral Researcher MPI for Intelligent Systems\n\n\n\n\n\n\nDiego Baptista Theuerkauf Ph.D. Student MPI for Intelligent Systems\n\n\n\n\n\n\nGabriela Lima Borges Data Scientist / Guest Researcher MPI for Evolutionary Anthropology 🧑‍💻 core package developer\n\n\n\n\n\n\nDr. Tracy Sweet Associate Professor UMD College of Education\n\n\n\n\n\n\nDr. Jean-Gabriel Young Assistant Professor The University of Vermont\n\n\n\n\n\n\nDr. Jeremy Koster Professor University of Cincinnati\n\n\n\n\n\n\nDr. Cody T. Ross Research Scientist MPI for Evolutionary Anthropology\n\n\n\n\n\n\nDr. Richard McElreath Professor MPI for Evolutionary Anthropology\n\n\n\n\n\n\nDr. Daniel Redhead Research Scientist MPI for Evolutionary Anthropology\n\n\n\n\n\n\nDr. Eleanor A. Power Assistant Professor LSE Department of Methodology"
  },
  {
    "objectID": "latest/tutorials.html",
    "href": "latest/tutorials.html",
    "title": "💻 Tutorials",
    "section": "",
    "text": "Choose your favourite language:\n\n\n  \n\nR\n\n\n\n  \n\nPython"
  },
  {
    "objectID": "latest/tutorials/R-tutorials.html",
    "href": "latest/tutorials/R-tutorials.html",
    "title": "💻 Tutorials",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n💻 Tutorial 01: Preparing your data for VIMuRe in R\n\n\n12 min\n\n\n\nbasics\n\n\nR\n\n\n\nThis tutorial will show you how to prepare your data for VIMuRe.\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "",
    "text": "Note\n\n\n\nIf you use VIMuRe in your research, please cite (De Bacco et al. 2023).\nTLDR: By the end of this tutorial, you should produce a data frame in the following format:"
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html#read-metadata",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html#read-metadata",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "3.1. Read metadata",
    "text": "3.1. Read metadata\nLet’s first subset the individual-level metadata to keep only the relevant village:\n# Keep track of where the edgelist files are stored\nRAW_CSV_FOLDER <- \"2010-0760_Data/Data/Raw_csv\"\n\n# Let's focus on just one village for now\nselected_village <- 1\n\n# Filter the individual-level metadata to keep only the relevant village\nresp <- subset(indivinfo, indivinfo$village == selected_village)\nresp$didsurv <- 1"
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html#read-village-data",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html#read-village-data",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "3.2. Read village data",
    "text": "3.2. Read village data\nNow, let’s read the village_1.csv file and merge it with the individual-level metadata:\n  village_file <- file.path(RAW_CSV_FOLDER, paste(\"village\", selected_village, \".csv\", sep = \"\"))\n  indiv <- read.csv(village_file, header = FALSE, as.is = TRUE)\n  colnames(indiv) <- c(\"hhid\", \"ppid\", \"gender\", \"age\")\n\n  ## gender (1-Male, 2-Female)\n  indiv$gender <- dplyr::recode(indiv$gender, \"Male\", \"Female\")\n  \n  ## pre-process pid to match the format in the individual-level metadata\n  indiv$pid <- ifelse(nchar(indiv$ppid)==2, paste(indiv$hhid, indiv$ppid, sep = \"\"),\n                      paste(indiv$hhid, 0, indiv$ppid, sep = \"\"))\n  \n  ## Select only the relevant columns\n  selected_cols <- c(\"pid\", \"resp_status\", \"religion\", \"caste\", \"didsurv\") \n  indiv <- merge(indiv, resp[,selected_cols], by = \"pid\", all.x = TRUE, all.y = TRUE) \nWhich produces a dataframe that looks like this:\nhead(indiv)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npid\nhhid\nppid\ngender\nage\nresp_status\nreligion\ncaste\ndidsurv\n\n\n\n\n100101\n1001\n1\nMale\n75\nNA\nNA\nNA\nNA\n\n\n100102\n1001\n2\nFemale\n55\nNA\nNA\nNA\nNA\n\n\n100103\n1001\n3\nMale\n24\nNA\nNA\nNA\nNA\n\n\n100104\n1001\n4\nFemale\n19\nNA\nNA\nNA\nNA\n\n\n100201\n1002\n1\nMale\n38\n1\n1\n3\n1\n\n\n100202\n1002\n2\nFemale\n27\n2\n1\n3\n1"
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html#read-reports-per-relationship-type",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html#read-reports-per-relationship-type",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "3.3 Read reports per relationship type",
    "text": "3.3 Read reports per relationship type\nThe survey that produced this data collected information on a number of different types of relationships, four of which were “double sampled” (i.e., asked about in two ways, who people go to for that type of support, and who comes to them). Specifically, they asked about borrowing and receiving money, giving and receiving advice, borrowing and lending household items like kerosene and rice, and visiting and receiving guests. These distinct questions are represented in the data files with the following names:\n\nborrowmoney,\nreceivemoney,\nhelpdecision,\nreceiveadvice,\nkeroricego,\nkeroricecome,\nvisitgo,\nvisitcome\n\nEach of these relationships is stored in a separate file. For example, the file borrowmoney1.csv contains information on who reported borrowing money from whom in village 1.\nWe can read each of these files using the read.csv() function. For example:\nfilepath_borrowmoney <- file.path(RAW_CSV_FOLDER, paste(\"borrowmoney\", selected_village, \".csv\", sep=\"\"))\nborrowmoney <- read.csv(filepath_borrowmoney, header = FALSE, as.is = TRUE, na = ALL_NA_CODES)\nThe ALL_NA_CODES variable is a vector of all the codes that, after inspection, we identified were used to represent missing values in the data:\nALL_NA_CODES <- c(\"9999999\", \"5555555\", \"7777777\", \"0\")\nWhat the data looks like\nThe data is stored here as a node list, but it will need to be further pre-processed as an edge list:\n      V1     V2     V3     V4 V5 V6 V7 V8 V9\n1 100201 107603     NA     NA NA NA NA NA NA\n2 100202 100201     NA     NA NA NA NA NA NA\n3 100601 101901 102601 115501 NA NA NA NA NA\n4 100602 100501 101902     NA NA NA NA NA NA\n5 100701 100801 102101     NA NA NA NA NA NA\n6 100702 100801 104001     NA NA NA NA NA NA\nEach row represents reports made by a single individual; the first number is the pid (the “person identifier”) of the individual who reported the relationship, whereas the remaining however many numbers listed in the same row are the pids of the individuals who were reported to be involved in the relationship."
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html#pre-process-the-data-to-build-the-edge-list",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html#pre-process-the-data-to-build-the-edge-list",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "3.4. Pre-process the data to build the edge list",
    "text": "3.4. Pre-process the data to build the edge list\nWe want the network data to be in the following format, plus a few additional columns:\n\n\n\ni\nj\n\n\n\n\n100201\n107603\n\n\n100202\n100201\n\n\n100601\n101901\n\n\n100601\n102601\n\n\n100601\n115501\n\n\n100602\n100501\n\n\n100602\n101902\n\n\n100701\n100801\n\n\n100701\n102101\n\n\n100702\n100801\n\n\n\nTo achieve this, we will need to pivot the data.\ntie_type <- \"borrowmoney\"\n\n# Example with the borrowmoney data\ndf <- tidyr::pivot_longer(borrowmoney, cols=!V1, values_drop_na=TRUE)\n\n# View(df) to see what the data looks like\nThis produces a bogus name column, which we can drop. We should also rename the columns to something more meaningful. It is important that we add a respondent column. This will be the pid of the individual who reported the relationship.\ndf <- df %>% \n    dplyr::select(-name) %>% \n    rename(i=V1, j=value) %>% \n    mutate(respondent=i)\n\n# Let's also add a column for the tie type\ndf$tie_type <- tie_type\n\n# Let's add a weight column too\ndf$weight <- 1\nNow, if the question was “Did you borrow money from anyone?”, then the i column should be the respondent, and the j column should be the person who was reported to have borrowed money from the respondent. However, if the question was “Did anyone borrow money from you?”, then the i column should be the person who was reported to have borrowed money from the respondent, and the j column should be the respondent. We can use the tie_type variable to determine which of these two scenarios applies.\nif(tie_type %in% c(\"receivemoney\", \"receiveadvice\", \"keroricecome\", \"visitcome\")) {\n    df <- df %>% \n        rename(i=j, j=i)\n}\nLet’s reorder the columns to guarantee we can rbind the data frames of all relationship tipes together later.\ndf <- df %>% dplyr::select(respondent, i, j, tie_type, weight)\nwhich produces the following data frame:\nhead(df)\n\n\n\nrespondent\ni\nj\ntie_type\nweight\n\n\n\n\n100201\n107603\n100201\nborrowmoney\n1\n\n\n100202\n100201\n100202\nborrowmoney\n1\n\n\n100601\n101901\n100601\nborrowmoney\n1\n\n\n100601\n102601\n100601\nborrowmoney\n1\n\n\n100601\n115501\n100601\nborrowmoney\n1\n\n\n100602\n100501\n100602\nborrowmoney\n1\n\n\n\nThe above is the format we want the data to be in! This format will make it easier to work with VIMuRe.\nUse the full pre-processing script below to pre-process all the data for all tie types and save it to a single vil1_edges.csv file. We also save the indiv data frame to a vil1_meta.csv file.\n\n\nClick to see full pre-processing script\n\nVALID_VILLAGE_IDS <- c(1:12, 14:21, 23:77) # village IDs 13 and 22 are missing\nALL_NA_CODES <- c(\"9999999\", \"5555555\", \"7777777\", \"0\") # codes for missing values\n\nRAW_CSV_FOLDER <- \"2010-0760_Data/Data/Raw_csv\"\n\n\nfor (i in VALID_VILLAGE_IDS){\n  selected_village <- i\n  ## Read in the files that include details of each individual and of each sharing unit\n  resp <- subset(indivinfo, indivinfo$village==selected_village)\n  resp$didsurv <- 1\n \n  village_file <- file.path(RAW_CSV_FOLDER, paste(\"village\", selected_village, \".csv\", sep = \"\"))\n  indiv <- read.csv(village_file, header = FALSE, as.is = TRUE)\n  colnames(indiv) <- c(\"hhid\", \"ppid\", \"gender\", \"age\")\n  ## gender (1-Male, 2-Female)\n  indiv$gender <- dplyr::recode(indiv$gender, \"Male\", \"Female\")\n  \n  indiv$pid <- ifelse(nchar(indiv$ppid)==2, paste(indiv$hhid, indiv$ppid, sep = \"\"),\n                      paste(indiv$hhid, 0, indiv$ppid, sep = \"\"))\n  \n  ## Select only the relevant columns\n  selected_cols <- c(\"pid\", \"resp_status\", \"religion\", \"caste\", \"didsurv\") \n  indiv <- merge(indiv, resp[,selected_cols], by = \"pid\", all.x = TRUE, all.y = TRUE) \n  \n  ## Read in the files that include details on each relationship\n\n  filepath_borrowmoney <- file.path(RAW_CSV_FOLDER, paste(\"borrowmoney\", selected_village, \".csv\", sep=\"\"))\n  borrowmoney <- read.csv(filepath_borrowmoney, header = FALSE, as.is = TRUE, na = ALL_NA_CODES)\n\n  filepath_receivemoney <- file.path(RAW_CSV_FOLDER, paste(\"lendmoney\", selected_village, \".csv\", sep=\"\"))\n  receivemoney <- read.csv(filepath_receivemoney, header = FALSE, as.is = TRUE, na = ALL_NA_CODES)\n\n  filepath_giveadvice <- file.path(RAW_CSV_FOLDER, paste(\"giveadvice\", selected_village, \".csv\", sep=\"\"))\n  receiveadvice <- read.csv(filepath_giveadvice, header = FALSE, as.is = TRUE, na = ALL_NA_CODES)\n\n  filepath_helpdecision <- file.path(RAW_CSV_FOLDER, paste(\"helpdecision\", selected_village, \".csv\", sep=\"\"))\n  helpdecision <- read.csv(filepath_helpdecision, header = FALSE, as.is = TRUE, na = ALL_NA_CODES)\n\n  filepath_keroricecome <- file.path(RAW_CSV_FOLDER, paste(\"keroricecome\", selected_village, \".csv\", sep=\"\"))\n  keroricecome <- read.csv(filepath_keroricecome, header = FALSE, as.is = TRUE, na = ALL_NA_CODES)\n\n  filepath_keroricego <- file.path(RAW_CSV_FOLDER, paste(\"keroricego\", selected_village, \".csv\", sep=\"\"))\n  keroricego <- read.csv(filepath_keroricego, header = FALSE, as.is = TRUE, na = ALL_NA_CODES)\n\n  filepath_visitcome <- file.path(RAW_CSV_FOLDER, paste(\"visitcome\", selected_village, \".csv\", sep=\"\"))\n  visitcome <- read.csv(filepath_visitcome, header = FALSE, as.is = TRUE, na = ALL_NA_CODES)\n\n  filepath_visitgo <- file.path(RAW_CSV_FOLDER, paste(\"visitgo\", selected_village, \".csv\", sep=\"\"))\n  visitgo <- read.csv(filepath_visitgo, header = FALSE, as.is = TRUE, na = ALL_NA_CODES)\n  \n  tietypes <- list(\"borrowmoney\" = borrowmoney,\n                   \"receivemoney\" = receivemoney,\n                   \"helpdecision\" = helpdecision,\n                   \"receiveadvice\" = receiveadvice,\n                   \"keroricego\" = keroricego,\n                   \"keroricecome\" = keroricecome,\n                   \"visitgo\" = visitgo,\n                   \"visitcome\" = visitcome)\n  \n  edges <- data.frame()\n  \n  for(selected_tie_type in 1:length(tietypes)){\n    df <- tidyr::pivot_longer(tietypes[[selected_tie_type]], cols=!V1, values_drop_na=TRUE)\n\n    # Some pre-processing\n    df <- df %>% \n        dplyr::select(-name) %>% \n        rename(i=V1, j=value) %>% \n        mutate(respondent=i)\n\n    # Let's also add a column for the tie type\n    df$tie_type <- tie_type\n\n    # Let's add a weight column too\n    df$weight <- 1\n\n    # We need to reverse the direction of the edge for some tie types\n    if(tie_type %in% c(\"receivemoney\", \"receiveadvice\", \"keroricecome\", \"visitcome\")) {\n        df <- df %>% rename(i=j, j=i)\n    }\n\n    edges <- rbind(edges, df)\n  }\n\n  write.csv(edges, file = paste0(\"vil\",i,\"_edges.csv\"))\n  write.csv(indiv, file = paste0(\"vil\",i,\"_meta.csv\"))\n\n}"
  },
  {
    "objectID": "latest/tutorials/python-tutorials.html",
    "href": "latest/tutorials/python-tutorials.html",
    "title": "💻 Tutorials",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n💻 Tutorial 01: Preparing your data for VIMuRe in python\n\n\n13 min\n\n\n\nbasics\n\n\npython\n\n\n\nThis tutorial will show you how to prepare your data for VIMuRe.\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "",
    "text": "Note\n\n\n\nIf you use VIMuRe in your research, please cite (De Bacco et al. 2023).\nTLDR: By the end of this tutorial, you should produce a data frame in the following format:"
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html#read-metadata",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html#read-metadata",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "3.1. Read metadata",
    "text": "3.1. Read metadata\nLet’s first subset the individual-level metadata to keep only the relevant village:\n    # Keep track of where the edgelist files are stored\n    RAW_CSV_FOLDER = \"2010-0760_Data/Data/Raw_csv\"\n\n    # Let's focus on just one village for now\n    selected_village = 1\n\n    # Filter the individual-level metadata to keep only the relevant village\n    resp = indivinfo[indivinfo[\"village\"] == 1].copy()\n    resp[\"didsurv\"] = 1"
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html#read-village-data",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html#read-village-data",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "3.2. Read village data",
    "text": "3.2. Read village data\nNow, let’s read the village_1.csv file and merge it with the individual-level metadata:\n  village_file = os.path.join(RAW_CSV_FOLDER, f\"village{selected_village}.csv\")\n  indiv = pd.read_csv(village_file, header = None, names=[\"hhid\", \"ppid\", \"gender\", \"age\"])\n\n  ## gender (1-Male, 2-Female)\n  indiv[\"gender\"] = indiv[\"gender\"].map({1: \"Male\", 2: \"Female\"})\n\n  ## pre-process pid to match the format in the individual-level metadata\n  indiv[\"ppid\"] = indiv[\"ppid\"].astype(str)\n  indiv[\"hhid\"] = indiv[\"hhid\"].astype(str)\n  indiv[\"pid\"] =  indiv.apply(lambda x: f'{x[\"hhid\"]}{0 if len(x[\"ppid\"]) != 2 else None}{x[\"ppid\"]}', axis=1)\n\n  ## Select only the relevant columns\n  selected_cols = [\"pid\", \"resp_status\", \"religion\", \"caste\", \"didsurv\"]\n  indiv = pd.merge(indiv, resp[selected_cols], on=\"pid\", how=\"left\")\nWhich produces a dataframe that looks like this:\nindiv.head()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhhid\nppid\ngender\nage\npid\nresp_status\nreligion\ncaste\ndidsurv\n\n\n\n\n0\n1001\n1\nMale\n75\n100101\nnan\nnan\nnan\nnan\n\n\n1\n1001\n2\nFemale\n55\n100102\nnan\nnan\nnan\nnan\n\n\n2\n1001\n3\nMale\n24\n100103\nnan\nnan\nnan\nnan\n\n\n3\n1001\n4\nFemale\n19\n100104\nnan\nnan\nnan\nnan\n\n\n4\n1002\n1\nMale\n38\n100201\nHead of Household\nHINDUISM\nOBC\n1"
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html#read-reports-per-relationship-type",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html#read-reports-per-relationship-type",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "3.3 Read reports per relationship type",
    "text": "3.3 Read reports per relationship type\nThe survey that produced this data collected information on a number of different types of relationships, four of which were “double sampled” (i.e., asked about in two ways, who people go to for that type of support, and who comes to them). Specifically, they asked about borrowing and receiving money, giving and receiving advice, borrowing and lending household items like kerosene and rice, and visiting and receiving guests. These distinct questions are represented in the data files with the following names:\n\nborrowmoney,\nreceivemoney,\nhelpdecision,\nreceiveadvice,\nkeroricego,\nkeroricecome,\nvisitgo,\nvisitcome\n\nEach of these relationships is stored in a separate file. For example, the file borrowmoney1.csv contains information on who reported borrowing money from whom in village 1.\nWe can read each of these files using the pd.read_csv() function. For example:\nfilepath_borrowmoney = os.path.join(RAW_CSV_FOLDER, f\"borrowmoney{selected_village}.csv\")\nborrowmoney = pd.read_csv(filepath_borrowmoney, header=None, na_values=ALL_NA_CODES, dtype=str)\nThe ALL_NA_CODES variable is a vector of all the codes that, after inspection, we identified were used to represent missing values in the data:\nALL_NA_CODES = [\"9999999\", \"5555555\", \"7777777\", \"0\"]\nWhat the data looks like\nThe data is stored here as a node list, but it will need to be further pre-processed as an edge list:\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n0\n100201\n107603\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n1\n100202\n100201\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n2\n100601\n101901\n102601\n115501\nnan\nnan\nnan\nnan\nnan\n\n\n3\n100602\n100501\n101902\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n4\n100701\n100801\n102101\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n5\n100702\n100801\n104001\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n\nEach row represents reports made by a single individual; the first number is the pid (the “person identifier”) of the individual who reported the relationship, whereas the remaining however many numbers listed in the same row are the pids of the individuals who were reported to be involved in the relationship."
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html#pre-process-the-data-to-build-the-edge-list",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html#pre-process-the-data-to-build-the-edge-list",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "3.4. Pre-process the data to build the edge list",
    "text": "3.4. Pre-process the data to build the edge list\nWe want the network data to be in the following format, plus a few additional columns:\n\n\n\ni\nj\n\n\n\n\n100201\n107603\n\n\n100202\n100201\n\n\n100601\n101901\n\n\n100601\n102601\n\n\n100601\n115501\n\n\n100602\n100501\n\n\n100602\n101902\n\n\n100701\n100801\n\n\n100701\n102101\n\n\n100702\n100801\n\n\n\nTo achieve this, we will need to pivot the data.\ntie_type = \"borrowmoney\"\n\n# Example with the borrowmoney data\ndf = pd.melt(borrowmoney, id_vars=[0]).dropna()\nThis produces a bogus variable column, which we can drop. We should also rename the columns to something more meaningful. It is important that we add a respondent column. This will be the pid of the individual who reported the relationship.\ndf = df.drop(columns=\"variable\")\\\n       .rename(columns={0: \"i\", \"value\": \"j\"})\\\n       .assign(respondent=lambda x: x[\"i\"])\n\n# Let's also add a column for the tie type\ndf = df.assign(tie_type=tie_type)\n\n# Let's add a weight column too\ndf = df.assign(weight=1)\nNow, if the question was “Did you borrow money from anyone?”, then the i column should be the respondent, and the j column should be the person who was reported to have borrowed money from the respondent. However, if the question was “Did anyone borrow money from you?”, then the i column should be the person who was reported to have borrowed money from the respondent, and the j column should be the respondent. We can use the tie_type variable to determine which of these two scenarios applies.\nif tie_type in [\"borrowmoney\", \"keroricego\", \"visitgo\"]:\n    df = df.rename(columns={\"i\": \"j\", \"j\": \"i\"})\nLet’s reorder the columns to guarantee we can rbind the data frames of all relationship tipes together later.\ndf = df[[\"respondent\", \"i\", \"j\", \"tie_type\", \"weight\"]]\nwhich produces the following data frame:\ndf.head()\n\n\n\n\nrespondent\ni\nj\ntie_type\nweight\n\n\n\n\n0\n100201\n107603\n100201\nborrowmoney\n1\n\n\n1\n100202\n100201\n100202\nborrowmoney\n1\n\n\n2\n100601\n101901\n100601\nborrowmoney\n1\n\n\n3\n100602\n100501\n100602\nborrowmoney\n1\n\n\n4\n100701\n100801\n100701\nborrowmoney\n1\n\n\n5\n100702\n100801\n100702\nborrowmoney\n1\n\n\n\nThe above is the format we want the data to be in! This format will make it easier to work with VIMuRe.\nUse the full pre-processing script below to pre-process all the data for all tie types and save it to a single vil1_edges.csv file. We also save the indiv data frame to a vil1_meta.csv file.\n\n\nClick to see full pre-processing script\n\n# village IDs 13 and 22 are missing\nVALID_VILLAGE_IDS = [i for i in range(1, 77+1) if i != 13 and i != 22] \n\n# codes for missing values\nALL_NA_CODES = [\"9999999\", \"5555555\", \"7777777\", \"0\"] \n\nRAW_CSV_FOLDER = \"2010-0760_Data/Data/Raw_csv\"\n\nfor i in VALID_VILLAGE_IDS:\n  selected_village = i\n\n  ## Read in the files that include details of each individual and of each sharing unit\n  resp = indivinfo[indivinfo[\"village\"] == selected_village].copy()\n  resp[\"didsurv\"] = 1\n\n  village_file = os.path.join(RAW_CSV_FOLDER, f\"village{selected_village}.csv\")\n  indiv = pd.read_csv(village_file, header=None, dtype=str)\n  indiv.columns = [\"hhid\", \"ppid\", \"gender\", \"age\"]\n  \n  indiv[\"age\"] = indiv[\"age\"].astype(int)\n\n  ## gender (1-Male, 2-Female)\n  indiv[\"gender\"] = indiv[\"gender\"].map({\"1\": \"Male\", \"2\": \"Female\"})\n\n  indiv[\"pid\"] = indiv.apply(lambda x: f'{x[\"hhid\"]}{x[\"ppid\"]}' \n                                        if len(x[\"ppid\"]) == 2 \n                                        else f'{x[\"hhid\"]}0{x[\"ppid\"]}',\n                                        axis=1)\n\n  ## Select only the relevant columns\n  selected_cols = [\"pid\", \"resp_status\", \"religion\", \"caste\", \"didsurv\"]\n  indiv = pd.merge(indiv, resp[selected_cols], on=\"pid\")\n\n\n  ## Read in the files that include details on each relationship\n\n  filepath_borrowmoney = os.path.join(RAW_CSV_FOLDER, f\"borrowmoney{selected_village}.csv\")\n  borrowmoney = pd.read_csv(filepath_borrowmoney, header = None, na_values = ALL_NA_CODES, dtype=str)\n\n  filepath_receivemoney = os.path.join(RAW_CSV_FOLDER, f\"lendmoney{selected_village}.csv\")\n  receivemoney = pd.read_csv(filepath_receivemoney, header = None, na_values = ALL_NA_CODES, dtype=str)\n\n  filepath_giveadvice = os.path.join(RAW_CSV_FOLDER, f\"giveadvice{selected_village}.csv\")\n  receiveadvice = pd.read_csv(filepath_giveadvice, header = None, na_values = ALL_NA_CODES, dtype=str)\n\n  filepath_helpdecision = os.path.join(RAW_CSV_FOLDER, f\"helpdecision{selected_village}.csv\")\n  helpdecision = pd.read_csv(filepath_helpdecision, header = None, na_values = ALL_NA_CODES, dtype=str)\n\n  filepath_keroricecome = os.path.join(RAW_CSV_FOLDER, f\"keroricecome{selected_village}.csv\")\n  keroricecome = pd.read_csv(filepath_keroricecome, header = None, na_values = ALL_NA_CODES, dtype=str)\n\n  filepath_keroricego = os.path.join(RAW_CSV_FOLDER, f\"keroricego{selected_village}.csv\")\n  keroricego = pd.read_csv(filepath_keroricego, header = None, na_values = ALL_NA_CODES, dtype=str)\n\n  filepath_visitcome = os.path.join(RAW_CSV_FOLDER, f\"visitcome{selected_village}.csv\")\n  visitcome = pd.read_csv(filepath_visitcome, header = None, na_values = ALL_NA_CODES, dtype=str)\n\n  filepath_visitgo = os.path.join(RAW_CSV_FOLDER, f\"visitgo{selected_village}.csv\")\n  visitgo = pd.read_csv(filepath_visitgo, header = None, na_values = ALL_NA_CODES, dtype=str)\n\n  tietypes <- {\"borrowmoney\": borrowmoney,\n               \"receivemoney\": receivemoney,\n               \"helpdecision\": helpdecision,\n               \"receiveadvice\": receiveadvice,\n               \"keroricego\": keroricego,\n               \"keroricecome\": keroricecome,\n               \"visitgo\": visitgo,\n               \"visitcome\": visitcome}\n\n  edges = []\n\n  for selected_tie_type, df_tie in tietypes.items():\n\n    df = pd.melt(df_tie, id_vars=[0]).dropna()\n\n    df = df.drop(columns=\"variable\")\\\n       .rename(columns={0: \"i\", \"value\": \"j\"})\\\n       .assign(respondent=lambda x: x[\"i\"])\n\n    # Let's also add a column for the tie type\n    df = df.assign(tie_type=selected_tie_type)\n\n    # Let's add a weight column too\n    df = df.assign(weight=1)\n\n    if tie_type in [\"borrowmoney\", \"keroricego\", \"visitgo\"]:\n      df = df.rename(columns={\"i\": \"j\", \"j\": \"i\"})\n\n    df = df[[\"respondent\", \"i\", \"j\", \"tie_type\", \"weight\"]]\n\n    edges.append(df)\n\n  edges = pd.concat(edges)\n\n  edges.to_csv(f\"vil{i}_edges.csv\", index=False)\n  indiv.to_csv(f\"vil{i}_meta.csv\", index=False)"
  }
]