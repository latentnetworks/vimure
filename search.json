[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "VIMuRe v0.1 (latest)",
    "section": "",
    "text": "Suppose you want to find out the “true” network of social ties between \\(n\\) individuals and you query \\(m\\) “reporters” within this network (where \\(m \\le n\\)) about such ties. These ties could, for instance, represent relationships commonly studied in the social sciences — such as loaning money, giving advice, or sharing food.\nSuppose, also, that you ask them questions in both directions: “Who does person \\(i\\) borrow money from?” and “Who does person \\(i\\) lend money to?” As it is doubtful that the responses given by the reporters will match perfectly, you will almost surely end up with varying perspectives on what should be the same relationship and, so too, varying perspectives on the structure of the overall social network. The question then is, how do you make sense of this data in the face of inconsistent reports and potentially unreliable reporters?\nThe model in the VIMuRe package is our proposed solution to this problem. It fits a latent network model from multiply-sampled social network data using Bayesian inference, returning a posterior distribution that can later be used to obtain samples or a point-estimate network (e.g., as an igraph object). The package was written in Python and R and is available on GitHub (https://github.com/latentnetworks/vimure).\n\n\n\nInput: multiply-sampled social network data as an edgelist or an igraph object.\nOutput: a fitted latent network model that can be used to obtain samples or a point-estimate network (an igraph object) from the posterior distribution of the fitted model.\n\n\n\n\n\nHead to the 📦 Installation page to learn how to install the package (either R or Python).\nCheck out the 💻 Tutorials page to learn how to use the package."
  },
  {
    "objectID": "latest/install.html",
    "href": "latest/install.html",
    "title": "📦 Installation",
    "section": "",
    "text": "VIMuRe is available in both R and Python. The R implementation is a wrapper around the Python implementation. Both packages are in active development and are not yet on CRAN or PyPI. Use the installation instructions below to install the latest development version.\nChoose your language:"
  },
  {
    "objectID": "latest/install.html#step-01-install-reticulate",
    "href": "latest/install.html#step-01-install-reticulate",
    "title": "📦 Installation",
    "section": "Step 01: Install reticulate",
    "text": "Step 01: Install reticulate\nOpen your R console and type the following command:\ninstall.packages(\"reticulate\")\n\n\n\n\n\n\nWhy do I need this package?\n\n\n\n\n\n\nOur core code is written in python, so we use reticulate to integrate our model in R. This package allows you to use Python within your R session in a seamless, high-performance interoperable way.\nreticulate will look for the python installed on your computer. If for some reason it cannot find it, you may be prompted to download and install miniconda.\n\nminiconda is the recommended installation method for most users, as it is easier to ensure that the newly installed python is isolated from other python installs you have in your system.\nIf you initially declined the miniconda installation prompt, you can later manually install miniconda by running reticulate::install_miniconda()."
  },
  {
    "objectID": "latest/install.html#step-02-install-the-latest-vimure-v0.1",
    "href": "latest/install.html#step-02-install-the-latest-vimure-v0.1",
    "title": "📦 Installation",
    "section": "Step 02: Install the latest vimure (v0.1)",
    "text": "Step 02: Install the latest vimure (v0.1)\nIn your R console, type the following commands:\nrequire(devtools)\ndevtools::install_github(\"latentnetworks/vimure\", subdir=\"src/R\", ref=\"main\")\nCheck out devtools package documentation if you are not familiar with it."
  },
  {
    "objectID": "latest/install.html#step-03-install-the-python-package",
    "href": "latest/install.html#step-03-install-the-python-package",
    "title": "📦 Installation",
    "section": "Step 03: Install the Python package",
    "text": "Step 03: Install the Python package\nYou must install the python package before using the R package. This is because the R package is a wrapper around the Python package. You can do this without leaving R, though. Just type the following command in your R console:\nrequire(vimure)\nvimure::install_vimure()\nIf you are not using RStudio, i.e., you are using R in the terminal, you may need to restart your R session after installing the Python package.\nNot a fan of having to do this python setup? Please add a message to this discussion to tell us you would like to see an easier installation process for R."
  },
  {
    "objectID": "latest/people.html",
    "href": "latest/people.html",
    "title": "People",
    "section": "",
    "text": "Who we are\nThe people behind the conception, development, and maintenance of VIMuRe are listed below.\n\n\n\n\n\nDr. Caterina De Bacco CyberValley Research Group Leader MPI for Intelligent Systems 🧑‍💻 core package developer\n\n\n\n\n\n\nMartina Contisciani Ph.D. Student MPI for Intelligent Systems 🧑‍💻 core package developer\n\n\n\n\n\n\nDr. Jon Cardoso-Silva Assist. Prof. Lecturer LSE Data Science Institute 🧑‍💻 core package developer\n\n\n\n\n\n\nDr. Hadiseh Safdari Postdoctoral Researcher MPI for Intelligent Systems\n\n\n\n\n\n\nDiego Baptista Theuerkauf Ph.D. Student MPI for Intelligent Systems\n\n\n\n\n\n\nGabriela Lima Borges Data Scientist / Guest Researcher MPI for Evolutionary Anthropology 🧑‍💻 core package developer\n\n\n\n\n\n\nDr. Tracy Sweet Associate Professor UMD College of Education\n\n\n\n\n\n\nDr. Jean-Gabriel Young Assistant Professor The University of Vermont\n\n\n\n\n\n\nDr. Jeremy Koster Professor University of Cincinnati\n\n\n\n\n\n\nDr. Cody T. Ross Research Scientist MPI for Evolutionary Anthropology\n\n\n\n\n\n\nDr. Richard McElreath Professor MPI for Evolutionary Anthropology\n\n\n\n\n\n\nDr. Daniel Redhead Research Scientist MPI for Evolutionary Anthropology\n\n\n\n\n\n\nDr. Eleanor A. Power Assistant Professor LSE Department of Methodology"
  },
  {
    "objectID": "latest/tutorials.html",
    "href": "latest/tutorials.html",
    "title": "💻 Tutorials",
    "section": "",
    "text": "Choose your favourite language:\n\n\n  \n\nR\n\n\n\n  \n\nPython"
  },
  {
    "objectID": "latest/tutorials/R-tutorials.html",
    "href": "latest/tutorials/R-tutorials.html",
    "title": "💻 Tutorials",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n💻 Tutorial 01: Preparing your data for VIMuRe in R\n\n\n24 min\n\n\n\nbasics\n\n\nR\n\n\n\nThis tutorial will show you how to prepare your data for VIMuRe.\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "",
    "text": "Note\n\n\n\nIf you use VIMuRe in your research, please cite (De Bacco et al. 2023).\nTLDR: By the end of this tutorial, you should produce a data frame in the following format:"
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html#read-metadata",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html#read-metadata",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "3.1. Read metadata",
    "text": "3.1. Read metadata\nLet’s first subset the individual-level metadata to keep only the relevant village:\n# Keep track of where the edgelist files are stored\nRAW_CSV_FOLDER <- \"2010-0760_Data/Data/Raw_csv\"\n\n# Let's focus on just one village for now\nselected_village <- 1\n\n# Filter the individual-level metadata to keep only the relevant village\nresp <- subset(indivinfo, indivinfo$village == selected_village)\nresp$didsurv <- 1\n\n\n\n\n\n\nNote\n\n\n\nThe didsurv column is a dummy variable that indicates whether the individual participated in the survey. We will need this information later to tell our Bayesian model who participated in the survey."
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html#read-village-data",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html#read-village-data",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "3.2. Read village data",
    "text": "3.2. Read village data\nNow, let’s read the village_1.csv file and merge it with the individual-level metadata:\nvillage_file <- file.path(RAW_CSV_FOLDER, paste(\"village\", selected_village, \".csv\", sep = \"\"))\nindiv <- read.csv(village_file, header = FALSE, as.is = TRUE)\ncolnames(indiv) <- c(\"hhid\", \"ppid\", \"gender\", \"age\")\n\n## gender (1-Male, 2-Female)\nindiv$gender <- dplyr::recode(indiv$gender, \"Male\", \"Female\")\n\n## pre-process pid to match the format in the individual-level metadata\nindiv$pid <- ifelse(nchar(indiv$ppid)==2, paste(indiv$hhid, indiv$ppid, sep = \"\"),\n                    paste(indiv$hhid, 0, indiv$ppid, sep = \"\"))\n\n## Select only the relevant columns\nselected_cols <- c(\"pid\", \"resp_status\", \"religion\", \"caste\", \"didsurv\") \nindiv <- merge(indiv, resp[,selected_cols], by = \"pid\", all.x = TRUE, all.y = TRUE) \nWhich produces a dataframe that looks like this:\nhead(indiv)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npid\nhhid\nppid\ngender\nage\nresp_status\nreligion\ncaste\ndidsurv\n\n\n\n\n100101\n1001\n1\nMale\n75\nNA\nNA\nNA\nNA\n\n\n100102\n1001\n2\nFemale\n55\nNA\nNA\nNA\nNA\n\n\n100103\n1001\n3\nMale\n24\nNA\nNA\nNA\nNA\n\n\n100104\n1001\n4\nFemale\n19\nNA\nNA\nNA\nNA\n\n\n100201\n1002\n1\nMale\n38\n1\n1\n3\n1\n\n\n100202\n1002\n2\nFemale\n27\n2\n1\n3\n1"
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html#read-reports-per-relationship-type",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html#read-reports-per-relationship-type",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "3.3 Read reports per relationship type",
    "text": "3.3 Read reports per relationship type\nThe survey that produced this data collected information on a number of different types of relationships, four of which were “double sampled” (i.e., asked about in two ways, who people go to for that type of support, and who comes to them). Specifically, they asked about borrowing and receiving money, giving and receiving advice, borrowing and lending household items like kerosene and rice, and visiting and receiving guests. These distinct questions are represented in the data files with the following names:\n\nlendmoney,\nborrowmoney,\ngiveadvice,\nhelpdecision,\nkeroricecome,\nkeroricego,\nvisitcome\nvisitgo\n\nEach of these relationships is stored in a separate file. For example, the file lendmoney1.csv contains information on who reported lending money to whom in village 1.\nWe can read each of these files using the read.csv() function. For example:\nfilepath_lendmoney <- file.path(RAW_CSV_FOLDER, paste(\"lendmoney\", selected_village, \".csv\", sep=\"\"))\nlendmoney <- read.csv(filepath_lendmoney, header = FALSE, as.is = TRUE, na = ALL_NA_CODES)\nThe ALL_NA_CODES variable is a vector of all the codes that, after inspection, we identified were used to represent missing values in the data:\nALL_NA_CODES <- c(\"9999999\", \"5555555\", \"7777777\", \"0\")\nWhat the data look like\nThe data is stored here as a node list, but it will need to be further pre-processed as an edge list:\n\n\n\n\nV1\nV2\nV3\nV4\nV5\nV6\nV7\nV8\nV9\n\n\n\n\n100201\n107603\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n100202\n102902\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n100601\n101901\n102601\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n100602\n100501\n101902\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n100701\n100801\n102101\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n100702\n100801\n104001\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\n\nEach row represents reports made by a single individual; the first number is the pid (the “person identifier”) of the individual who reported the relationship, whereas the remaining however many numbers listed in the same row are the pids of the individuals who were reported to be involved in the relationship."
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html#pre-process-the-data-to-build-the-edge-list",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html#pre-process-the-data-to-build-the-edge-list",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "3.4. Pre-process the data to build the edge list",
    "text": "3.4. Pre-process the data to build the edge list\nWe want the network data to be in the following format, plus a few additional columns:\n\n\n\n\nego\nalter\n\n\n\n\n100201\n107603\n\n\n100202\n100201\n\n\n100601\n101901\n\n\n100601\n102601\n\n\n100601\n115501\n\n\n100602\n100501\n\n\n100602\n101902\n\n\n100701\n100801\n\n\n100701\n102101\n\n\n100702\n100801\n\n\n\n\nTo achieve this, we will need to pivot the data.\ntie_type <- \"lendmoney\"\n\n# Example with the lendmoney data\nedgelist_lendmoney <- tidyr::pivot_longer(lendmoney, cols=!V1, values_drop_na=TRUE)\n\n# View(edgelist_lendmoney) to see what the data look like\nThis produces a bogus name column, which we can drop. We should also rename the columns to something more meaningful. It is important that we add a respondent column. This will be the pid of the individual who reported the relationship.\nedgelist_lendmoney <- edgelist_lendmoney %>% \n    dplyr::select(-name) %>% \n    rename(ego=V1, alter=value) %>% \n    mutate(reporter=ego)\n\n# Let's also add a column for the tie type\nedgelist_lendmoney$tie_type <- tie_type\n\n# Let's add a weight column too\nedgelist_lendmoney$weight <- 1\nproducing head(edgelist_lendmoney):\n\n\n\n\nego\nalter\nreporter\ntie_type\nweight\n\n\n\n\n100201\n107603\n100201\nlendmoney\n1\n\n\n100202\n102902\n100202\nlendmoney\n1\n\n\n100601\n101901\n100601\nlendmoney\n1\n\n\n100601\n102601\n100601\nlendmoney\n1\n\n\n100602\n100501\n100602\nlendmoney\n1\n\n\n100602\n101902\n100602\nlendmoney\n1\n\n\n\n\nSo far, we only added tie_type = \"lendmoney\" to the data frame, but to make full use of VIMuRe, we also need to add the “flipped question” to the data frame, which in this case is tie_type = \"borrowmoney\". This is because the survey asked two different questions about borrowing and receiving money. The process is the same as before, except that we need to flip the ego and alter columns at the end.\nThere are also some other data cleaning steps that we need to perform: remove self-loops, remove duplicates and keep only reports made by registered reporters. We will do all of that inside a function in the next section, to make it easier to re-use."
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html#create-a-function-to-get-the-data-for-a-given-village-and-tie-type",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html#create-a-function-to-get-the-data-for-a-given-village-and-tie-type",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "4.1. Create a function to get the data for a given village and tie type",
    "text": "4.1. Create a function to get the data for a given village and tie type\nThis function will also take care of the data cleaning steps that we described in the previous section. Importantly, it will also map the double-sampled tie types to the layer names we will use in VIMuRe.\n\n\nClick here to expand the code for the get_karnataka_survey_data() function\n\nget_karnataka_survey_data <- function(\n                                village_id, \n                                tie_type, \n                                indivinfo,\n                                ties_layer_mapping = list(\n                                    borrowmoney = \"money\",\n                                    lendmoney = \"money\",\n                                    giveadvice = \"advice\",\n                                    helpdecision = \"advice\",\n                                    keroricego = \"kerorice\",\n                                    keroricecome = \"kerorice\",\n                                    visitgo = \"visit\",\n                                    visitcome = \"visit\"\n                                  ),\n                                all_na_codes=c(\"9999999\", \"5555555\", \"7777777\", \"0\"),\n                                raw_csv_folder=RAW_CSV_FOLDER){\n\n  # Filter the individual-level metadata to keep only the relevant village\n  resp <- subset(indivinfo, indivinfo$village == village_id)\n  resp$didsurv <- 1    \n\n  village_file <- file.path(raw_csv_folder, paste(\"village\", village_id, \".csv\", sep = \"\"))\n  metadata <- read.csv(village_file, header = FALSE, as.is = TRUE)\n  colnames(metadata) <- c(\"hhid\", \"ppid\", \"gender\", \"age\")\n\n  ## gender (1-Male, 2-Female)\n  metadata$gender <- dplyr::recode(metadata$gender, \"Male\", \"Female\")\n\n  ## pre-process pid to match the format in the individual-level metadata\n  metadata$pid <- ifelse(nchar(metadata$ppid)==2, paste(metadata$hhid, metadata$ppid, sep = \"\"),\n                         paste(metadata$hhid, 0, metadata$ppid, sep = \"\"))\n\n  ## Select only the relevant columns\n  selected_cols <- c(\"pid\", \"resp_status\", \"religion\", \"caste\", \"didsurv\") \n  metadata <- merge(metadata, resp[,selected_cols], by = \"pid\", all.x = TRUE, all.y = TRUE)\n\n\n  filepath <- file.path(raw_csv_folder, paste(tie_type, village_id, \".csv\", sep=\"\"))\n  df_raw <- read.csv(filepath, header = FALSE, as.is = TRUE, na = all_na_codes)\n\n  edgelist <- tidyr::pivot_longer(df_raw, cols=!V1, values_drop_na=TRUE)\n\n  edgelist <- edgelist %>% \n      dplyr::select(-name) %>% \n      rename(ego=V1, alter=value) %>% \n      mutate(reporter=ego)\n\n  # Let's also add a column for the tie type\n  edgelist$tie_type <- tie_type\n\n  # Let's add a weight column too\n  edgelist$weight <- 1\n\n  # If the question was \"Did you borrow money from anyone?\", then we need to flip the ego and alter columns\n  if(tie_type %in% c(\"borrowmoney\", \"helpdecision\", \"keroricego\", \"visitgo\")){\n    edgelist <- edgelist %>% rename(ego=alter, alter=ego)\n  }\n\n  # Create a layer column and reorder the columns to make it easier to work with VIMuRe later\n  edgelist <- edgelist %>% \n    mutate(layer = unlist(ties_layer_mapping[tie_type])) %>% \n    select(ego, alter, reporter, tie_type, layer, weight)\n\n  #### Further pre-processing steps ####\n\n  # Who could actually report on the ties?\n  reporters <- metadata %>%\n    filter(didsurv == 1) %>%\n    pull(pid) %>%\n    as.vector()\n  nodes <- reporters %>% union(edgelist$ego) %>% union(edgelist$alter)\n\n  # Only keep reports made by those who were MARKED as reporters in metadata CSV\n  edgelist <- edgelist %>% filter(reporter %in% reporters)\n\n  # Remove self-loops\n  edgelist <- edgelist %>% filter(ego != alter)\n\n  # Remove duplicates\n  edgelist <- edgelist %>% distinct()\n\n  return(list(edgelist=edgelist, reporters=reporters))\n\n}"
  },
  {
    "objectID": "latest/tutorials/R/tutorial01-data-preparation.html#getting-an-edgelist-per-layer",
    "href": "latest/tutorials/R/tutorial01-data-preparation.html#getting-an-edgelist-per-layer",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in R",
    "section": "4.2 Getting an edgelist per layer",
    "text": "4.2 Getting an edgelist per layer\nEach double-sampled tie type is mapped to a layer in VIMuRe. The mapping can be seen in the function we created above and is also shown below.\nties_layer_mapping = list(borrowmoney = \"money\",\n                          lendmoney = \"money\",\n                          giveadvice = \"advice\",\n                          helpdecision = \"advice\",\n                          keroricego = \"kerorice\",\n                          keroricecome = \"kerorice\",\n                          visitgo = \"visit\",\n                          visitcome = \"visit\")\nTherefore, to get the edgelist for, say the money layer, we need to combine the borrowmoney and lendmoney tie types. We can do this by using the get_karnataka_survey_data function we created above.\n\n# Get the edgelist for the money layer\noutput <- get_karnataka_survey_data(village_id = 1, tie_type = \"lendmoney\", indivinfo = indivinfo)\nedgelist_lendmoney <- output$edgelist\nreporters          <- output$reporters\n\nedgelist_borrowmoney <- get_karnataka_survey_data(village_id = 1, tie_type = \"borrowmoney\", indivinfo = indivinfo)$edgelist\n\nedgelist_money <- rbind(edgelist_lendmoney, edgelist_borrowmoney)\nwhich now gives us all the edges for the money layer:\nset.seed(100) # set the random seed for reproducibility\n\nedgelist_money %>% sample_n(size = 10, replace = FALSE)\n\n\n\nego\nalter\nreporter\ntie_type\nlayer\nweight\n\n\n\n\n111903\n111902\n111902\nborrowmoney\nmoney\n1\n\n\n104901\n104101\n104101\nborrowmoney\nmoney\n1\n\n\n111401\n109701\n109701\nborrowmoney\nmoney\n1\n\n\n118001\n112605\n112605\nborrowmoney\nmoney\n1\n\n\n106205\n106302\n106205\nlendmoney\nmoney\n1\n\n\n100701\n100801\n100701\nlendmoney\nmoney\n1\n\n\n111502\n108902\n111502\nlendmoney\nmoney\n1\n\n\n100501\n100801\n100801\nborrowmoney\nmoney\n1\n\n\n112601\n111903\n111903\nborrowmoney\nmoney\n1\n\n\n117301\n109505\n109505\nborrowmoney\nmoney\n1\n\n\n\nThe above is the format we want the data to be in! This format will make it easier to work with VIMuRe. Although, only the ego, alter, reporter columns are required. The tie_type, layer and weight columns are optional, but useful to have.\nUse the full pre-processing script below to pre-process all the data for all tie types and save it to a single vil1_money.csv file. We also save the respondents list to, as a data frame, to a vil1_money_respondents.csv file.\n\n\nClick to see full pre-processing script\n\n# Load the required packages\nlibrary(tidyverse)\n\n# Set the working directory accordingly\n# setwd(\"C:/Users/.../karnataka_survey\")\n\nVALID_VILLAGE_IDS <- c(1:12, 14:21, 23:77) # village IDs 13 and 22 are missing\nRAW_CSV_FOLDER <- \"2010-0760_Data/Data/Raw_csv\"\n\nties_layer_mapping = list(borrowmoney = \"money\",\n                          lendmoney = \"money\",\n                          giveadvice = \"advice\",\n                          helpdecision = \"advice\",\n                          keroricego = \"kerorice\",\n                          keroricecome = \"kerorice\",\n                          visitgo = \"visit\",\n                          visitcome = \"visit\")\n\nget_karnataka_survey_data <- function(\n                                village_id, \n                                tie_type, \n                                indivinfo,\n                                ties_layer_mapping = list(\n                                    borrowmoney = \"money\",\n                                    lendmoney = \"money\",\n                                    giveadvice = \"advice\",\n                                    helpdecision = \"advice\",\n                                    keroricego = \"kerorice\",\n                                    keroricecome = \"kerorice\",\n                                    visitgo = \"visit\",\n                                    visitcome = \"visit\"\n                                  ),\n                                all_na_codes=c(\"9999999\", \"5555555\", \"7777777\", \"0\"),\n                                raw_csv_folder=RAW_CSV_FOLDER){\n\n  # Filter the individual-level metadata to keep only the relevant village\n  resp <- subset(indivinfo, indivinfo$village == village_id)\n  resp$didsurv <- 1    \n\n  village_file <- file.path(raw_csv_folder, paste(\"village\", village_id, \".csv\", sep = \"\"))\n  metadata <- read.csv(village_file, header = FALSE, as.is = TRUE)\n  colnames(metadata) <- c(\"hhid\", \"ppid\", \"gender\", \"age\")\n\n  ## gender (1-Male, 2-Female)\n  metadata$gender <- dplyr::recode(metadata$gender, \"Male\", \"Female\")\n\n  ## pre-process pid to match the format in the individual-level metadata\n  metadata$pid <- ifelse(nchar(metadata$ppid)==2, paste(metadata$hhid, metadata$ppid, sep = \"\"),\n                         paste(metadata$hhid, 0, metadata$ppid, sep = \"\"))\n\n  ## Select only the relevant columns\n  selected_cols <- c(\"pid\", \"resp_status\", \"religion\", \"caste\", \"didsurv\") \n  metadata <- merge(metadata, resp[,selected_cols], by = \"pid\", all.x = TRUE, all.y = TRUE)\n\n\n  filepath <- file.path(raw_csv_folder, paste(tie_type, village_id, \".csv\", sep=\"\"))\n  df_raw <- read.csv(filepath, header = FALSE, as.is = TRUE, na = all_na_codes)\n\n  edgelist <- tidyr::pivot_longer(df_raw, cols=!V1, values_drop_na=TRUE)\n\n  edgelist <- edgelist %>% \n      dplyr::select(-name) %>% \n      rename(ego=V1, alter=value) %>% \n      mutate(reporter=ego)\n\n  # Let's also add a column for the tie type\n  edgelist$tie_type <- tie_type\n\n  # Let's add a weight column too\n  edgelist$weight <- 1\n\n  # If the question was \"Did you borrow money from anyone?\", then we need to flip the ego and alter columns\n  if(tie_type %in% c(\"borrowmoney\", \"helpdecision\", \"keroricego\", \"visitgo\")){\n    edgelist <- edgelist %>% rename(ego=alter, alter=ego)\n  }\n\n  # Create a layer column and reorder the columns to make it easier to work with VIMuRe later\n  edgelist <- edgelist %>% \n    mutate(layer = unlist(ties_layer_mapping[tie_type])) %>% \n    select(ego, alter, reporter, tie_type, layer, weight)\n\n  #### Further pre-processing steps ####\n\n  # Who could actually report on the ties?\n  reporters <- metadata %>%\n    filter(didsurv == 1) %>%\n    pull(pid) %>%\n    as.vector()\n  nodes <- reporters %>% union(edgelist$ego) %>% union(edgelist$alter)\n\n  # Only keep reports made by those who were MARKED as reporters in metadata CSV\n  edgelist <- edgelist %>% filter(reporter %in% reporters)\n\n  # Remove self-loops\n  edgelist <- edgelist %>% filter(ego != alter)\n\n  # Remove duplicates\n  edgelist <- edgelist %>% distinct()\n\n  return(list(edgelist=edgelist, reporters=reporters))\n\n}\n\nget_layer <- function(village_id, layer_name, indivinfo,\n                      raw_csv_folder=RAW_CSV_FOLDER){\n\n  tie_types <- list(\n    money = c(\"borrowmoney\", \"lendmoney\"),\n    advice = c(\"giveadvice\", \"helpdecision\"),\n    kerorice = c(\"keroricego\", \"keroricecome\"),\n    visit = c(\"visitgo\", \"visitcome\")\n  )\n\n  selected_tie_types <- tie_types[[layer_name]]\n\n\n  edgelist <- data.frame()\n  reporters <- c()\n\n  for(tie_type in selected_tie_types){\n    data <- get_karnataka_survey_data(village_id, tie_type, indivinfo, raw_csv_folder=raw_csv_folder)\n    edgelist <- rbind(edgelist, data$edgelist)\n    reporters <- union(reporters, data$reporters)\n  }\n\n  return(list(edgelist=edgelist, reporters=reporters))\n}\n\n\n# Read Stata DTA files\nindivinfo <- haven::read_dta(\"datav4.0/Data/2. Demographics and Outcomes/individual_characteristics.dta\")\nindivinfo <- indivinfo[!duplicated(indivinfo$pid)==TRUE,] ## one individual (6109803) is repeated twice.\n\nfor(i in VALID_VILLAGE_IDS){\n  for(layer_name in c(\"money\", \"advice\", \"kerorice\", \"visit\")){\n    \n    data <- get_layer(i, layer_name, indivinfo, raw_csv_folder=RAW_CSV_FOLDER)\n    edgelist <- data$edgelist\n    reporters <- data$reporters\n\n    # Save the edgelist\n    edgelist_file <- file.path(paste(\"village\", i, \"_\", layer_name, \".csv\", sep = \"\"))\n    write.csv(edgelist, edgelist_file, row.names = FALSE)\n\n    # Save the reporters\n    reporters_file <- file.path(paste(\"village\", i, \"_\", layer_name, \"_reporters.csv\", sep = \"\"))\n    write.csv(data.frame(reporter=reporters), reporters_file, row.names = FALSE)\n\n  }\n}"
  },
  {
    "objectID": "latest/tutorials/python-tutorials.html",
    "href": "latest/tutorials/python-tutorials.html",
    "title": "💻 Tutorials",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n💻 Tutorial 01: Preparing your data for VIMuRe in python\n\n\n25 min\n\n\n\nbasics\n\n\npython\n\n\n\nThis tutorial will show you how to prepare your data for VIMuRe.\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "",
    "text": "Note\n\n\n\nIf you use VIMuRe in your research, please cite (De Bacco et al. 2023).\nTLDR: By the end of this tutorial, you should produce a data frame in the following format:"
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html#read-metadata",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html#read-metadata",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "3.1. Read metadata",
    "text": "3.1. Read metadata\nLet’s first subset the individual-level metadata to keep only the relevant village:\n# Keep track of where the edgelist files are stored\nRAW_CSV_FOLDER = \"2010-0760_Data/Data/Raw_csv\"\n\n# Let's focus on just one village for now\nselected_village = 1\n\n# Filter the individual-level metadata to keep only the relevant village\nresp = indivinfo[indivinfo[\"village\"] == 1].copy()\nresp[\"didsurv\"] = 1\n\n\n\n\n\n\nNote\n\n\n\nThe didsurv column is a dummy variable that indicates whether the individual participated in the survey. We will need this information later to tell our Bayesian model who participated in the survey."
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html#read-village-data",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html#read-village-data",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "3.2. Read village data",
    "text": "3.2. Read village data\nNow, let’s read the village_1.csv file and merge it with the individual-level metadata:\nvillage_file = os.path.join(RAW_CSV_FOLDER, f\"village{selected_village}.csv\")\nindiv = pd.read_csv(village_file, header = None, names=[\"hhid\", \"ppid\", \"gender\", \"age\"])\n\n## gender (1-Male, 2-Female)\nindiv[\"gender\"] = indiv[\"gender\"].map({1: \"Male\", 2: \"Female\"})\n\n## pre-process pid to match the format in the individual-level metadata\nindiv[\"ppid\"] = indiv[\"ppid\"].astype(str)\nindiv[\"hhid\"] = indiv[\"hhid\"].astype(str)\nindiv[\"pid\"] =  indiv.apply(lambda x: f'{x[\"hhid\"]}{0 if len(x[\"ppid\"]) != 2 else \"\"}{x[\"ppid\"]}', axis=1)\n\n## Select only the relevant columns\nselected_cols = [\"pid\", \"resp_status\", \"religion\", \"caste\", \"didsurv\"]\nindiv = pd.merge(indiv, resp[selected_cols], on=\"pid\", how=\"left\")\nWhich produces a dataframe that looks like this:\nindiv.head()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhhid\nppid\ngender\nage\npid\nresp_status\nreligion\ncaste\ndidsurv\n\n\n\n\n0\n1001\n1\nMale\n75\n100101\nnan\nnan\nnan\nnan\n\n\n1\n1001\n2\nFemale\n55\n100102\nnan\nnan\nnan\nnan\n\n\n2\n1001\n3\nMale\n24\n100103\nnan\nnan\nnan\nnan\n\n\n3\n1001\n4\nFemale\n19\n100104\nnan\nnan\nnan\nnan\n\n\n4\n1002\n1\nMale\n38\n100201\nHead of Household\nHINDUISM\nOBC\n1"
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html#read-reports-per-relationship-type",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html#read-reports-per-relationship-type",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "3.3 Read reports per relationship type",
    "text": "3.3 Read reports per relationship type\nThe survey that produced this data collected information on a number of different types of relationships, four of which were “double sampled” (i.e., asked about in two ways, who people go to for that type of support, and who comes to them). Specifically, they asked about borrowing and receiving money, giving and receiving advice, borrowing and lending household items like kerosene and rice, and visiting and receiving guests. These distinct questions are represented in the data files with the following names:\n\nlendmoney,\nborrowmoney,\ngiveadvice,\nhelpdecision,\nkeroricecome,\nkeroricego,\nvisitcome\nvisitgo\n\nEach of these relationships is stored in a separate file. For example, the file lendmoney1.csv contains information on who reported lending money to whom in village 1.\nWe can read each of these files using the pd.read_csv() function. For example:\nfilepath_lendmoney = os.path.join(RAW_CSV_FOLDER, f\"lendmoney{selected_village}.csv\")\nlendmoney = pd.read_csv(filepath_lendmoney, header=None, na_values=ALL_NA_CODES, dtype=str)\nThe ALL_NA_CODES variable is a vector of all the codes that, after inspection, we identified were used to represent missing values in the data:\nALL_NA_CODES = [\"9999999\", \"5555555\", \"7777777\", \"0\"]\nWhat the data look like\nThe data is stored here as a node list, but it will need to be further pre-processed as an edge list:\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n100201\n107603\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n100202\n102902\nnan\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n100601\n101901\n102601\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n100602\n100501\n101902\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n100701\n100801\n102101\nnan\nnan\nnan\nnan\nnan\nnan\n\n\n\n\nEach row represents reports made by a single individual; the first number is the pid (the “person identifier”) of the individual who reported the relationship, whereas the remaining however many numbers listed in the same row are the pids of the individuals who were reported to be involved in the relationship."
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html#pre-process-the-data-to-build-the-edge-list",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html#pre-process-the-data-to-build-the-edge-list",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "3.4. Pre-process the data to build the edge list",
    "text": "3.4. Pre-process the data to build the edge list\nWe want the network data to be in the following format, plus a few additional columns:\n\n\n\n\nego\nalter\n\n\n\n\n100201\n107603\n\n\n100202\n100201\n\n\n100601\n101901\n\n\n100601\n102601\n\n\n100601\n115501\n\n\n100602\n100501\n\n\n100602\n101902\n\n\n100701\n100801\n\n\n100701\n102101\n\n\n100702\n100801\n\n\n\n\nTo achieve this, we will need to pivot the data.\ntie_type = \"lendmoney\"\n\n# Example with the lendmoney data\nedgelist_lendmoney = pd.melt(lendmoney, id_vars=[0]).dropna()\nThis produces a bogus variable column, which we can drop. We should also rename the columns to something more meaningful. It is important that we add a respondent column. This will be the pid of the individual who reported the relationship.\nedgelist_lendmoney = edgelist_lendmoney.drop(columns=\"variable\")\\\n       .rename(columns={0: \"ego\", \"value\": \"alter\"})\\\n       .assign(reporter=lambda x: x[\"ego\"])\n\n# Let's also add a column for the tie type\nedgelist_lendmoney = edgelist_lendmoney.assign(tie_type=tie_type)\n\n# Let's add a weight column too\nedgelist_lendmoney = edgelist_lendmoney.assign(weight=1)\nproducing edgelist_lendmoney.head():\n\n\n\n\nego\nalter\nreporter\ntie_type\nweight\n\n\n\n\n100201\n107603\n100201\nlendmoney\n1\n\n\n100202\n102902\n100202\nlendmoney\n1\n\n\n100601\n101901\n100601\nlendmoney\n1\n\n\n100602\n100501\n100602\nlendmoney\n1\n\n\n100701\n100801\n100701\nlendmoney\n1\n\n\n\n\nSo far, we only added tie_type = \"lendmoney\" to the data frame, but to make full use of VIMuRe, we also need to add the “flipped question” to the data frame, which in this case is tie_type = \"borrowmoney\". This is because the survey asked two different questions about borrowing and receiving money. The process is the same as before, except that we need to flip the ego and alter columns at the end.\nThere are also some other data cleaning steps that we need to perform: remove self-loops, remove duplicates and keep only reports made by registered reporters. We will do all of that inside a function in the next section, to make it easier to re-use."
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html#create-a-function-to-get-the-data-for-a-given-village-and-tie-type",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html#create-a-function-to-get-the-data-for-a-given-village-and-tie-type",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "4.1. Create a function to get the data for a given village and tie type",
    "text": "4.1. Create a function to get the data for a given village and tie type\nThis function will also take care of the data cleaning steps that we described in the previous section. Importantly, it will also map the double-sampled tie types to the layer names we will use in VIMuRe.\n\n\nClick here to expand the code for the get_karnataka_survey_data() function\n\ndef get_karnataka_survey_data(village_id: int, tie_type: str,\n                              indivinfo: pd.DataFrame,\n                              ties_layer_mapping={\n                                  \"borrowmoney\": \"money\",\n                                  \"lendmoney\": \"money\",\n                                  \"giveadvice\": \"advice\",\n                                  \"helpdecision\": \"advice\",\n                                  \"keroricego\": \"kerorice\",\n                                  \"keroricecome\": \"kerorice\",\n                                  \"visitgo\": \"visit\",\n                                  \"visitcome\": \"visit\",\n                              },\n                              all_na_codes=[\"9999999\", \"5555555\", \"7777777\", \"0\"],\n                              raw_csv_folder=RAW_CSV_FOLDER):\n    \"\"\"\n    Read the raw data for a given tie type and village id, \n    and return two dataframes: the edgelist and the list of respondents.\n\n    Parameters\n    ----------\n    village_id : int\n        The village id, between 1 and 10.\n    tie_type : str\n        The tie type\n    indivinfo : pd.DataFrame\n        The individual-level metadata\n    all_na_codes : list, optional\n        The list of codes that should be interpreted as missing values, by default [\"9999999\", \"5555555\", \"7777777\", \"0\"]\n    raw_csv_folder : str, optional\n        The path to the folder containing the raw csv files, by default \"2010-0760_Data/Data/Raw_csv\"\n\n    Returns\n    -------\n\n    edgelist : pd.DataFrame\n        The edgelist\n\n    respondents : list\n        The respondent metadata\n\n    \"\"\"\n\n    # Filter the individual-level metadata to keep only the relevant village\n    resp = indivinfo[indivinfo[\"village\"] == village_id].copy()\n    resp[\"didsurv\"] = 1\n\n    village_file = os.path.join(raw_csv_folder, f\"village{village_id}.csv\")\n    metadata = pd.read_csv(village_file, header = None, names=[\"hhid\", \"ppid\", \"gender\", \"age\"])\n\n    ## gender (1-Male, 2-Female)\n    metadata[\"gender\"] = metadata[\"gender\"].map({1: \"Male\", 2: \"Female\"})\n\n    ## pre-process pid to match the format in the individual-level metadata\n    metadata[\"ppid\"] = metadata[\"ppid\"].astype(str)\n    metadata[\"hhid\"] = metadata[\"hhid\"].astype(str)\n    metadata[\"pid\"] =  metadata.apply(lambda x: f'{x[\"hhid\"]}{0 if len(x[\"ppid\"]) != 2 else \"\"}{x[\"ppid\"]}', axis=1)\n\n    ## Select only the relevant columns\n    selected_cols = [\"pid\", \"resp_status\", \"religion\", \"caste\", \"didsurv\"]\n    metadata = pd.merge(metadata, resp[selected_cols], on=\"pid\", how=\"left\")\n\n    # Read the raw data\n    filepath = os.path.join(raw_csv_folder, f\"{tie_type}{village_id}.csv\")\n    df_raw = pd.read_csv(filepath, header=None, na_values=all_na_codes, dtype=str)\n\n    # Example with the data\n    edgelist = pd.melt(df_raw, id_vars=[0]).dropna()\n\n    edgelist = edgelist.drop(columns=\"variable\")\\\n          .rename(columns={0: \"ego\", \"value\": \"alter\"})\\\n          .assign(reporter=lambda x: x[\"ego\"])\n\n    # Let's also add a column for the tie type\n    edgelist = edgelist.assign(tie_type=tie_type)\n\n    # Let's add a weight column too\n    edgelist = edgelist.assign(weight=1)\n\n    # If the question was \"Did you borrow money from anyone?\", then we need to flip the ego and alter columns\n    if tie_type in [\"borrowmoney\", \"helpdecision\", \"keroricego\", \"visitgo\"]:\n        edgelist = edgelist.rename(columns={\"ego\": \"alter\", \"alter\": \"ego\"})\n\n    edgelist[\"layer\"] = edgelist[\"tie_type\"].map(ties_layer_mapping)\n\n    # Reorder the columns to make it easier to read\n    edgelist = edgelist[[\"ego\", \"alter\", \"reporter\", \"tie_type\", \"layer\", \"weight\"]]\n\n    #### Further pre-processing steps ####\n\n    # Who could actually report on the ties?\n    reporters = set(metadata[metadata[\"didsurv\"] == 1][\"pid\"])\n    nodes = reporters.union(set(edgelist[\"ego\"])).union(set(edgelist[\"alter\"]))\n\n    # Only keep reports made by those who were MARKED as reporters in metadata CSV\n    edgelist = edgelist[edgelist[\"reporter\"].isin(reporters)].copy()\n\n    # Remove self-loops\n    edgelist = edgelist[edgelist[\"ego\"] != edgelist[\"alter\"]].copy()\n\n    # Remove duplicates\n    edgelist.drop_duplicates(inplace=True)\n\n    return edgelist, reporters"
  },
  {
    "objectID": "latest/tutorials/python/tutorial01-data-preparation.html#getting-an-edgelist-per-layer",
    "href": "latest/tutorials/python/tutorial01-data-preparation.html#getting-an-edgelist-per-layer",
    "title": "💻 Tutorial 01: Preparing your data for VIMuRe in python",
    "section": "4.2 Getting an edgelist per layer",
    "text": "4.2 Getting an edgelist per layer\nEach double-sampled tie type is mapped to a layer in VIMuRe. The mapping can be seen in the function we created above and is also shown below.\nties_layer_mapping={\n    \"borrowmoney\": \"money\",\n    \"lendmoney\": \"money\",\n    \"giveadvice\": \"advice\",\n    \"helpdecision\": \"advice\",\n    \"keroricego\": \"kerorice\",\n    \"keroricecome\": \"kerorice\",\n    \"visitgo\": \"visit\",\n    \"visitcome\": \"visit\",\n}\nTherefore, to get the edgelist for, say the money layer, we need to combine the borrowmoney and lendmoney tie types. We can do this by using the get_karnataka_survey_data function we created above.\n\n# Get the edgelist for the money layer\nedgelist_lendmoney, respondents =\\\n  get_karnataka_survey_data(village_id=1, tie_type=\"lendmoney\", indivinfo=indivinfo)\n\nedgelist_borrowmoney, _ = \\\n  get_karnataka_survey_data(village_id=1, tie_type=\"borrowmoney\", indivinfo=indivinfo)\n\nedgelist_money = pd.concat([edgelist_lendmoney, edgelist_borrowmoney], axis=0)\nwhich now gives us all the edges for the money layer:\nedgelist_money.sample(n=10, random_state=1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nego\nalter\nreporter\ntie_type\nlayer\nweight\n\n\n\n\n235\n103101\n103201\n103201\nborrowmoney\nmoney\n1\n\n\n229\n101201\n102901\n102901\nborrowmoney\nmoney\n1\n\n\n130\n111904\n112602\n111904\nlendmoney\nmoney\n1\n\n\n40\n113201\n104001\n104001\nborrowmoney\nmoney\n1\n\n\n14\n101303\n115704\n101303\nlendmoney\nmoney\n1\n\n\n345\n112901\n113601\n113601\nborrowmoney\nmoney\n1\n\n\n50\n104801\n104901\n104901\nborrowmoney\nmoney\n1\n\n\n97\n108803\n107503\n108803\nlendmoney\nmoney\n1\n\n\n241\n102901\n103701\n103701\nborrowmoney\nmoney\n1\n\n\n198\n117202\n115504\n117202\nlendmoney\nmoney\n1\n\n\n\n\nThe above is the format we want the data to be in! This format will make it easier to work with VIMuRe. Although, only the ego, alter, reporter columns are required. The tie_type, layer and weight columns are optional, but useful to have.\nUse the full pre-processing script below to pre-process all the data for all tie types and save it to a single vil1_money.csv file. We also save the reporters list to, as a data frame, to a vil1_money_reporters.csv file.\n\n\nClick to see full pre-processing script\n\nimport os\nimport pandas as pd\n\n# village IDs 13 and 22 are missing\nVALID_VILLAGE_IDS = [i for i in range(1, 77+1) if i != 13 and i != 22] \n\nRAW_CSV_FOLDER = \"2010-0760_Data/Data/Raw_csv\"\n\nties_layer_mapping={\n    \"borrowmoney\": \"money\",\n    \"lendmoney\": \"money\",\n    \"giveadvice\": \"advice\",\n    \"giveadvice\": \"advice\",\n    \"keroricego\": \"kerorice\",\n    \"keroricecome\": \"kerorice\",\n    \"visitgo\": \"visit\",\n    \"visitcome\": \"visit\",\n}\n\ndef get_karnataka_survey_data(village_id: int, tie_type: str,\n                              indivinfo: pd.DataFrame,\n                              ties_layer_mapping=ties_layer_mapping,\n                              all_na_codes=[\"9999999\", \"5555555\", \"7777777\", \"0\"],\n                              raw_csv_folder=RAW_CSV_FOLDER):\n    \"\"\"\n    Read the raw data for a given tie type and village id, \n    and return two dataframes: the edgelist and the list of respondents.\n\n    Parameters\n    ----------\n    village_id : int\n        The village id, between 1 and 10.\n    tie_type : str\n        The tie type\n    indivinfo : pd.DataFrame\n        The individual-level metadata\n    all_na_codes : list, optional\n        The list of codes that should be interpreted as missing values, by default [\"9999999\", \"5555555\", \"7777777\", \"0\"]\n    raw_csv_folder : str, optional\n        The path to the folder containing the raw csv files, by default \"2010-0760_Data/Data/Raw_csv\"\n\n    Returns\n    -------\n\n    edgelist : pd.DataFrame\n        The edgelist\n\n    respondents : list\n        The respondent metadata\n\n    \"\"\"\n\n    # Filter the individual-level metadata to keep only the relevant village\n    resp = indivinfo[indivinfo[\"village\"] == village_id].copy()\n    resp[\"didsurv\"] = 1\n\n    village_file = os.path.join(raw_csv_folder, f\"village{village_id}.csv\")\n    metadata = pd.read_csv(village_file, header = None, names=[\"hhid\", \"ppid\", \"gender\", \"age\"])\n\n    ## gender (1-Male, 2-Female)\n    metadata[\"gender\"] = metadata[\"gender\"].map({1: \"Male\", 2: \"Female\"})\n\n    ## pre-process pid to match the format in the individual-level metadata\n    metadata[\"ppid\"] = metadata[\"ppid\"].astype(str)\n    metadata[\"hhid\"] = metadata[\"hhid\"].astype(str)\n    metadata[\"pid\"] =  metadata.apply(lambda x: f'{x[\"hhid\"]}{0 if len(x[\"ppid\"]) != 2 else \"\"}{x[\"ppid\"]}', axis=1)\n\n    ## Select only the relevant columns\n    selected_cols = [\"pid\", \"resp_status\", \"religion\", \"caste\", \"didsurv\"]\n    metadata = pd.merge(metadata, resp[selected_cols], on=\"pid\", how=\"left\")\n\n    # Read the raw data\n    filepath = os.path.join(raw_csv_folder, f\"{tie_type}{village_id}.csv\")\n    df_raw = pd.read_csv(filepath, header=None, na_values=all_na_codes, dtype=str)\n\n    # Example with the data\n    edgelist = pd.melt(df_raw, id_vars=[0]).dropna()\n\n    edgelist = edgelist.drop(columns=\"variable\")\\\n          .rename(columns={0: \"ego\", \"value\": \"alter\"})\\\n          .assign(reporter=lambda x: x[\"ego\"])\n\n    # Let's also add a column for the tie type\n    edgelist = edgelist.assign(tie_type=tie_type)\n\n    # Let's add a weight column too\n    edgelist = edgelist.assign(weight=1)\n\n    # If the question was \"Did you borrow money from anyone?\", then we need to flip the ego and alter columns\n    if tie_type in [\"borrowmoney\", \"helpdecision\", \"keroricego\", \"visitgo\"]:\n        edgelist = edgelist.rename(columns={\"ego\": \"alter\", \"alter\": \"ego\"})\n\n    edgelist[\"layer\"] = edgelist[\"tie_type\"].map(ties_layer_mapping)\n\n    # Reorder the columns to make it easier to read\n    edgelist = edgelist[[\"ego\", \"alter\", \"reporter\", \"tie_type\", \"layer\", \"weight\"]]\n\n    #### Further pre-processing steps ####\n\n    # Who could actually report on the ties?\n    reporters = set(metadata[metadata[\"didsurv\"] == 1][\"pid\"])\n    nodes = reporters.union(set(edgelist[\"ego\"])).union(set(edgelist[\"alter\"]))\n\n    # Only keep reports made by those who were MARKED as reporters in metadata CSV\n    edgelist = edgelist[edgelist[\"reporter\"].isin(reporters)].copy()\n\n    # Remove self-loops\n    edgelist = edgelist[edgelist[\"ego\"] != edgelist[\"alter\"]].copy()\n\n    # Remove duplicates\n    edgelist.drop_duplicates(inplace=True)\n\n    return edgelist, reporters\n\ndef get_layer(village_id, layer_name, indivinfo, \n              raw_csv_folder=RAW_CSV_FOLDER):\n\n    tie_types = {\n        \"money\": [\"lendmoney\", \"borrowmoney\"],\n        \"advice\": [\"giveadvice\", \"helpdecision\"],\n        \"kerorice\": [\"keroricego\", \"keroricecome\"],\n        \"visit\": [\"visitgo\", \"visitcome\"],\n    }\n\n    selected_tie_types = tie_types[layer_name]\n\n    edgelist = pd.DataFrame()\n    reporters = set()\n\n    for tie_type in selected_tie_types:\n        edgelist_, reporters_ = get_karnataka_survey_data(village_id=village_id, \n                                                            tie_type=tie_type, \n                                                            indivinfo=indivinfo,\n                                                            raw_csv_folder=raw_csv_folder)\n        edgelist = pd.concat([edgelist, edgelist_])\n        reporters = reporters.union(reporters_)\n\n    return edgelist, reporters\n\n\nindivinfo = pd.read_stata(\"datav4.0/Data/2. Demographics and Outcomes/individual_characteristics.dta\")\nindivinfo.drop_duplicates(subset=[\"pid\"], inplace=True) ## one individual (6109803) is repeated twice.\nindivinfo[\"pid\"] = indivinfo[\"pid\"].astype(str)\nindivinfo[\"hhid\"] = indivinfo[\"hhid\"].astype(str)\n\n\nfor i in VALID_VILLAGE_IDS:\n    for layer_name in [\"money\", \"advice\", \"kerorice\", \"visit\"]:\n      print(f\"Processing village {i}\")\n      edgelist, reporters = get_layer(village_id=i, \n                                        layer_name=layer_name, \n                                        indivinfo=indivinfo, \n                                        raw_csv_folder=RAW_CSV_FOLDER)\n      edgelist.to_csv(f\"vil{i}_{layer_name}.csv\", index=False)\n      # save reporters to a separate file\n      pd.DataFrame({\"reporter\": list(reporters)}).to_csv(f\"vil{i}_{layer_name}_reporters.csv\", index=False)\n\n    print(f\"Done with village {i}\")"
  }
]